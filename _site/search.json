[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to CBRC-SPEC Tutorials!",
    "section": "",
    "text": "This site is designed to guide Caltech students and staff through the full process of working with single-cell data—from formatting and processing to analysis—using the equipment and experimental setups commonly found at Caltech. Whether you’re just getting started or looking to refine your workflow, these tutorials provide step-by-step instructions tailored to our unique environment."
  },
  {
    "objectID": "index.html#explore-our-single-cell-workflows",
    "href": "index.html#explore-our-single-cell-workflows",
    "title": "Welcome to CBRC-SPEC Tutorials!",
    "section": "Explore Our Single Cell Workflows",
    "text": "Explore Our Single Cell Workflows\n\nClick a technology below to access step-by-step tutorials tailored to each single-cell assay.\n\n\nSingle-Cell RNA Sequencing Tutorials\n\n\n\n\n10x Genomics Chromium Single Cell 3’\n\n\n\n\n\n\n\nParse Biosciences Evercode WT\n\n\n\n\n\nSpatial Transcriptomics Tutorials\n\n\n\n\nseqFISH"
  },
  {
    "objectID": "seqspec.html",
    "href": "seqspec.html",
    "title": "What is seqspec?",
    "section": "",
    "text": "seqspec is a simple, standardized file format to describe how a genomics library was prepared and sequenced. Different genomics assays require unique processing steps. Including a seqspec file with your data makes it easy for others (and future you!) to reanalyze your dataset. Here we will give a brief description of the seqspec format. For a more in-depth description of seqspec and the seqspec file format, refer to the GitHub page."
  },
  {
    "objectID": "seqspec.html#understanding-the-seqspec-file-format",
    "href": "seqspec.html#understanding-the-seqspec-file-format",
    "title": "What is seqspec?",
    "section": "Understanding the seqspec File Format",
    "text": "Understanding the seqspec File Format\nA seqspec file is a YAML-formatted document with three main sections:\n\nAssay Info – metadata describing the assay and protocols used\n\nLibrary Structure – layout and sequence of regions in the library\n\nRead Structure – how the sequencing reads correspond to library regions\n\nEach section depends on the specific library preparation and sequencing technology used in your assay.\n\n\n\n\n\n\nNoteWhy YAML?\n\n\n\nYAML (short for “YAML Ain’t Markup Language”) is a lightweight, human-readable format that is easy to edit and interpret, yet structured enough for automated parsing by software. This balance makes it ideal for encoding experimental metadata that must be both transparent to researchers and machine-accessible for reproducible analysis."
  },
  {
    "objectID": "seqspec.html#section-1-assay-info",
    "href": "seqspec.html#section-1-assay-info",
    "title": "What is seqspec?",
    "section": "Section 1: Assay Info",
    "text": "Section 1: Assay Info\nThe first section describes the overall experiment — what assay was used, which kit, and how it was sequenced.\n\nBasic Format\n!Assay\nseqspec_version: 0.3.0\nassay_id: \nname: \ndoi: \ndate: \ndescription:\nmodalities: rna\nlib_struct: \nsequence_protocol: \nsequence_kit: \nlibrary_protocol: \nlibrary_kit:\nseqspec_version — version of the seqspec format used (this tutorial will use version 0.3.0)\nassay_id, name, doi, date, description — metadata describing the assay\nlibrary_protocol, library_kit — kit and reagents used for library prep\nsequence_protocol, sequence_kit — sequencing instrument and reagents used\n\n\nExample\nSuppose you used the Parse Biosciences Evercode WT Mega v2.0.1 dual index kit to generate an scRNA-seq library, sequenced on Illumina NovaSeq X. The corresponding seqspec file might look like so:\n!Assay\nseqspec_version: 0.3.0\nassay_id: Evercode-WT-mega-v2-dual-index\nname: Parse Evercode Mega WT v2 using dual Illumina multiplex index\ndoi: https://www.protocols.io/view/evercode-wt-mega-v2-2-1-8epv5xxrng1b/v1?step=21\ndate: 08 November 2023\ndescription: split-pool ligation-based transcriptome sequencing\nmodalities: rna\nlib_struct: https://igvf.github.io/seqspec/\nlibrary_protocol: single-nucleus RNA sequencing assay (OBI:0003109)\nlibrary_kit: Evercode WT Mega v2.0.1 dual index\nsequence_protocol: Illumina NovaSeq X (EFO:0022840)\nsequence_kit: NovaSeq X Series 25B Reagent Kit"
  },
  {
    "objectID": "seqspec.html#section-2-library-structure",
    "href": "seqspec.html#section-2-library-structure",
    "title": "What is seqspec?",
    "section": "Section 2: Library Structure",
    "text": "Section 2: Library Structure\nThe library structure section lists all regions in the sequencing library (from 5’ to 3’), such as primers, linkers, UMIs, and barcodes.\nEach region is defined with the following template:\n- !Region\n  parent_id: \n  region_id: \n  region_type:\n  name: \n  sequence_type: \n  sequence: \n  min_len: \n  max_len: \n  onlist: \n  regions: \nregion_id, region_type, name — identifies and describes the region\nparent_id — refers to the parent region (if it exists)\nsequence, sequence_type — specifies the nucleotide sequence and its type (e.g., fixed, onlist, variable)\nmin_len, max_len — defines expected sequence lengths\nonlist — references a file or list of valid sequences (e.g., known cell barcodes)\n\nNested Regions\nParent regions can contain multiple child regions, forming a hierarchical structure. Here’s a minimal example with one parent and two child regions:\nlibrary_spec:\n- !Region\n  parent_id: null\n  region_id: parent\n  ...\n  regions:\n  - !Region\n    parent_id: parent\n    region_id: region_1\n    ...\n    regions: null\n  - !Region\n    parent_id: parent\n    region_id: region_2\n    ...\n    regions: null\n\n\nExamples\nBelow are two example regions you might find in a seqspec file.\n\nExample 1: Illumina P5 primer\n- !Region\n  parent_id: null\n  region_id: P5\n  region_type: primer\n  name: P5\n  sequence_type: fixed\n  sequence: AATGATACGGCGACCACCGAGATCTACAC\n  min_len: 29\n  max_len: 29\n  onlist: null\n  regions: null\n\n\nExample 2: Parse Biosciences Evercode WT cell barcode\n- !Region\n  parent_id: null\n  region_id: BC\n  region_type: barcode\n  name: cell barcode\n  sequence_type: onlist\n  sequence: NNNNNNNNNNNNNNNN\n  min_len: 16\n  max_len: 16\n  onlist: !Onlist\n    location: local\n    filename: onlist.txt\n  regions: null\n\n\n\n\n\n\nNoteWhat is an Onlist?\n\n\n\nIn Parse Evercode libraries, barcode regions are validated against a fixed list of known barcodes called the “onlist”."
  },
  {
    "objectID": "seqspec.html#section-3-read-structure",
    "href": "seqspec.html#section-3-read-structure",
    "title": "What is seqspec?",
    "section": "Section 3: Read Structure",
    "text": "Section 3: Read Structure\nThe read structure section links your FASTQ files to specific sequencing reads.\nEach read entry looks like this:\n- !Read\n  read_id: \n  name: \n  modality: \n  primer_id: \n  min_len: \n  max_len: \n  strand: \n  files:\nread_id, name — identifies the read object\nprimer_id — links to the corresponding primer region\nstrand — direction of sequencing relative to the library layout\nmin_len, max_len — expected read length\nfiles — references the FASTQ files containing this read\n\nExample\nsequence_spec:\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 28\n  max_len: 28\n  strand: pos\n  files:\n  - !File\n    file_id: read_1\n    filename: read_1.fastq.gz\n    filetype: fastq.gz\n    filesize: 10 GB\n    url: https://example.org/read_1.fastq.gz\n    urltype: https\n    md5: d1410f93b53357d4f95edb0ba0d73c07\n\n\nStep 3: Validate Your seqspec file with seqspec check\nYou can use seqspec check command from the seqspec package to verify your seqspec file is correctly formatted.\nseqspec check seqspec.yaml\nIf your file is valid, the command will complete without errors; otherwise, it will print a description of any issues found in the specification.\n\n\n\n\n\n\nNoteInstall seqspec\n\n\n\nIn order to install seqspec, follow our installation instructions here."
  },
  {
    "objectID": "seqfish_pipeline.knit.html",
    "href": "seqfish_pipeline.knit.html",
    "title": "seqFISH exploratory data analysis",
    "section": "",
    "text": "Introduction\nIn this vignette, we will demonstrate an example analysis workflow for spatial transcriptomics data collected using the seqFISH technology. The analysis will cover quality control, normalization, dimension reduction, clustering, and univariate spatial statistics. The workflow will make use of functions implemented in the Voyager R package as well as other Bioconductor packages.\n\n\nDataset\nThe data used in this vignette are described in Integration of spatial and single-cell transcriptomic data elucidates mouse organogenesis. Briefly, seqFISH was use to profile 351 genes in several mouse embryos at the 8-12 somite stage (ss). We will focus on a single biological replicate, embryo 3. The raw and processed counts and corresponding metadata are available to download from the Marioni lab. Expression matrices, segmentation data, and segmented cell vertices are provided as R objects that can be readily imported into an R environment. The data relevant to this vignette have been converted to a SFE object and are available to download here from Box.\nThe data have been added to the SFEData package on Bioconductor and will be available in the release release.\nWe will begin by downloading the data and loading it in to R.\n\nlibrary(Voyager)\nlibrary(SFEData)\nlibrary(SingleCellExperiment)\nlibrary(SpatialExperiment)\nlibrary(SpatialFeatureExperiment)\nlibrary(batchelor)\nlibrary(scater)\nlibrary(scran)\nlibrary(bluster)\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(fossil)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(spdep)\nlibrary(BiocParallel)\n\ntheme_set(theme_bw())\n\n\n# Only Bioc release and above\nsfe &lt;- LohoffGastrulationData()\n#&gt; see ?SFEData and browseVignettes('SFEData') for documentation\n#&gt; loading from cache\n\nThe rows in the count matrix correspond to the 351 barcoded genes measured by seqFISH. Additionally, the authors provide some metadata, including the field of view and z-slice for each cell. We will filter the count matrix and metadata to include only cells from a single z-slice.\n\nnames(colData(sfe))\n#&gt;  [1] \"uniqueID\"                \"embryo\"                 \n#&gt;  [3] \"pos\"                     \"z\"                      \n#&gt;  [5] \"x_global\"                \"y_global\"               \n#&gt;  [7] \"x_global_affine\"         \"y_global_affine\"        \n#&gt;  [9] \"embryo_pos\"              \"embryo_pos_z\"           \n#&gt; [11] \"Area\"                    \"UMAP1\"                  \n#&gt; [13] \"UMAP2\"                   \"celltype_mapped_refined\"\n#&gt; [15] \"sample_id\"\n\n\nmask &lt;- colData(sfe)$z == 2\nsfe &lt;- sfe[,mask]\n\n\n\nQuality control\nWe will begin quality control (QC) of the cells by computing metrics that are common in single-cell analysis and store them in the colData field of the SFE object. Below, we compute the number of counts per cell. We will also compute the average and display it on the violin plot.\n\ncolData(sfe)$nCounts &lt;- colSums(counts(sfe))\navg &lt;- mean(colData(sfe)$nCounts)\n\nviolin &lt;- plotColData(sfe, \"nCounts\") +\n    geom_hline(yintercept = avg, color='red') +\n    theme(legend.position = \"top\") \n\nspatial &lt;- plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"seg_coords\")\n\nviolin + spatial\n\n\n\n\n\n\n\n\nNotably, the cells in this dataset have fewer counts than would be expected in a single-cell sequencing experiment and the cells with higher counts seem to be dispersed throughout the tissue. Fewer counts are expected in seqFISH experiments where probing for highly expressed genes may lead to optical crowding over multiple imaging rounds.\nSince the counts are collected from several fields of view, we will visualize the number of cells and total counts for each field separately.\n\npos &lt;- colData(sfe)$pos\ncounts_spl &lt;- split.data.frame(t(counts(sfe)), pos)\n\n# nCounts per FOV\ndf &lt;- map_dfr(counts_spl, rowSums, .id='pos') |&gt;\n    pivot_longer(cols=contains('embryo'), values_to = 'nCounts') |&gt;\n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    dplyr::filter(!is.na(nCounts))\n\ncells_fov &lt;- colData(sfe) |&gt; \n    as.data.frame() |&gt; \n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    ggplot(aes(pos,)) +\n    geom_bar() + \n    theme_minimal() + \n    labs(\n        x = \"\",\n        y = \"Number of cells\") + \n    theme(axis.text.x = element_text(angle = 90))\n\ncounts_fov &lt;- ggplot(df, aes(pos, nCounts)) +\n    geom_boxplot(outlier.size = 0.5) + \n    theme_minimal() + \n    labs(x = \"\", y = 'nCounts') + \n    theme(axis.text.x = element_text(angle = 90))\n\ncells_fov / counts_fov\n\n\n\n\n\n\n\n\nThere is some variability in the total number of counts in each field of view. It is not completely apparent what accounts for the low number of counts in some FOVs. For example, FOV 22 has the fewest number of cells, but comparably more counts are detected there than in regions with more cells (e.g. FOV 18).\nNext, will will compute the number of genes detected per cell, defined here as the number of genes with non-zero counts. We will again plot this metric for each FOV as is done above.\n\ncolData(sfe)$nGenes &lt;- colSums(counts(sfe) &gt; 0)\n\navg &lt;- mean(colData(sfe)$nGenes)\n\nviolin &lt;- plotColData(sfe, \"nGenes\") +\n    geom_hline(yintercept = avg, color='red') +\n    theme(legend.position = \"top\") \n\nspatial &lt;- plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"seg_coords\")\n\nviolin + spatial\n\n\n\n\n\n\n\n\nMany cells have fewer than 100 detected genes. This in part reflects that the panel of 351 probed genes was chosen to distinguish cell types at these developmental stages and that distinct cell types will likely express a small subset of the 351 genes. The authors also note that the gene panel consists of lowly expressed to moderately expressed genes. Taken together, these technical details can explain the relatively low number of counts and genes per cell.\nHere, we plot the number of genes detected per cell in each FOV.\n\ndf &lt;- map_dfr(counts_spl, ~ rowSums(.x &gt; 0), .id='pos') |&gt;\n    pivot_longer(cols = contains('embryo'), values_to = 'nGenes') |&gt;\n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    filter(!is.na(nGenes)) |&gt;\n    merge(df)\n\ngenes_fov &lt;- ggplot(df, aes(pos, nGenes)) +\n    geom_boxplot(outlier.size = 0.5) + \n    theme_bw() + \n    labs(x = \"\") + \n    theme(axis.text.x = element_text(angle = 90))\n\ngenes_fov\n\n\n\n\n\n\n\n\nThis plot mirrors the plot above for total counts. No single FOV stands out as an obvious outlier.\nThe authors have provided cell type assignments as metadata. We can assess whether the low quality cells tend to be located in a particular FOV.\n\nmeta &lt;- data.frame(colData(sfe)) \n\nmeta &lt;- meta |&gt; \n    group_by(pos) |&gt; \n    add_tally(name = \"nCells_FOV\") |&gt; \n    filter(celltype_mapped_refined %in% \"Low quality\") |&gt; \n    add_tally(name = \"nLQ_FOV\") |&gt; \n    mutate(prop_lq = nLQ_FOV/nCells_FOV) |&gt;\n    distinct(pos, prop_lq) |&gt; \n    ungroup() |&gt; \n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1)))\n\nprop_lq &lt;- ggplot(meta, aes(pos, prop_lq)) + \n    geom_bar(stat = 'identity' ) + \n    theme(axis.text.x = element_text(angle = 90)) \n\nprop_lq\n\n\n\n\n\n\n\n\nIt appears that FOV 26 and 31 have the largest fraction of low quality cells. Interestingly, these do not correspond to the FOVs with the largest number of cells overall.\nHere we plot nCounts vs. nGenes for each FOV.\n\ncount_vs_genes_p &lt;- ggplot(df, aes(nCounts, nGenes)) + \n  geom_point(\n    alpha = 0.5,\n    size = 1,\n    fill = \"white\"\n  ) +\n  facet_wrap(~ pos)\n\ncount_vs_genes_p \n\n\n\n\n\n\n\n\nAs in scRNA-seq, gene expression variance in seqFISH measurements is overdispersed compared to variance of counts that are Poisson distributed.\n\ngene_meta &lt;- map_dfr(counts_spl, colMeans, .id = 'pos') |&gt; \n  pivot_longer(cols = -pos, names_to = 'gene', values_to = 'mean')\n\ngene_meta &lt;- map_dfr(counts_spl, ~colVars(.x, useNames = TRUE), .id = 'pos') |&gt; \n  pivot_longer(-pos, names_to = 'gene', values_to='variance') |&gt; \n  full_join(gene_meta)\n#&gt; Joining with `by = join_by(pos, gene)`\n\nTo understand the mean-variance relationship, we compute the mean and variance for each gene among cells in tissue. As above, we will perform this calculation separately for each FOV\n\nggplot(gene_meta, aes(mean, variance)) + \n  geom_point(\n    alpha = 0.5,\n    size = 1,\n    fill = \"white\"\n  ) +\n  facet_wrap(~ pos) +\n  geom_abline(slope = 1, intercept = 0, color = \"red\") +\n  scale_x_log10() + scale_y_log10() +\n  annotation_logticks()\n\n\n\n\n\n\n\n\nThe red line represents the line \\(y = x\\), which is the mean-variance relationship that would be expected for Poisson distributed data. The data deviate from this expectation in each FOV. In each case, the variance is greater than what would be expected.\n\n\nData normalization and dimension reduction\nThe exploratory analysis above indicates the presence of batch effects corresponding to FOV. We will use a normalization scheme that is batch aware. As the SFE object inherits from the SpatialExperimentand SingleCellExperiment, classes, we can take advantage of normalization methods implemented in the scran and batchelor R packages.\nWe will first use the multiBatchNorm() function to scale the data within each batch. As noted in the documentation, the function uses median-based normalization on the ratio of the average counts between batches.\nBatch correction and dimension reduction is accomplished using fastMNN() which performs multi-sample PCA across multiple gene expression matrices to project all cells to a common low-dimensional space.\n\nsfe &lt;- multiBatchNorm(sfe, batch = pos)\nsfe_red &lt;- fastMNN(sfe, batch = pos, cos.norm = FALSE, d = 20)\n\nThe function fastMNN returns a batch-corrected matrix in the reducedDims slot of a SingleCellExperiment object. We will extract the relevant data and store them in the SFE ojbject.\n\nreducedDim(sfe, \"PCA\") &lt;- reducedDim(sfe_red, \"corrected\")\nassay(sfe, \"reconstructed\") &lt;- assay(sfe_red, \"reconstructed\") \n\nNow we will visualize the first two PCs in space. Here we notice that the PCs may show some spatial structure that correlates to biological niches of cells.\n\nspatialReducedDim(sfe, \"PCA\", ncomponents = 2, divergent = TRUE, diverge_center = 0)\n\n\n\n\n\n\n\n\nUnfortunately, FOV artifacts can still be seen.\n\n\nClustering\nMuch like in single cell analysis, we can use the batch-corrected data to cluster the cells. We will implement a graph-based clustering algorithm and plot the resulting clusters in space.\n\ncolData(sfe)$cluster &lt;- \n  clusterRows(reducedDim(sfe, \"PCA\"),\n                      BLUSPARAM = SNNGraphParam(\n                        cluster.fun = \"leiden\",\n                        cluster.args = list(\n                        resolution_parameter = 0.5,\n                        objective_function = \"modularity\")\n                        )\n              )\n\nThe plot below is colored by cluster ID and by the cell types provided by the author.\n\nplotSpatialFeature(sfe, c(\"cluster\", \"celltype_mapped_refined\"), \n                   colGeometryName = \"seg_coords\")\n\n\n\n\n\n\n\n\nThe authors have assigned cells to more types than are identified in the clustering step. In any case, the clustering results seem to recapitulate the major cell niches from the previous annotations. We can compute the Rand index using a function from the fossil package to assess the similarity between the two clustering results. A value of 1 would suggest the clustering results are identical, while a value of 0 would suggest that the results do not agree at all.\n\ng1 &lt;- as.numeric(colData(sfe)$cluster)\ng2 &lt;- as.numeric(colData(sfe)$celltype_mapped_refined)\n\nrand.index(g1, g2)\n#&gt; [1] 0.8429139\n\nThe relatively large Rand index suggests that cells are often found in the same cluster in both cases.\n\n\nUnivariate Spatial Statistics\nAt this point, we may be interested in identifying genes that exhibit spatial variability, or whose expression depends on spatial location within the tissue. Measures of spatial autocorrelation can be useful in identifyign genes that display spatial variablity. Among the most common measures are Moran’s I and Geary’s C. In the latter case, a less than 1 indicates positive spatial autocorrelation, while a value larger than 1 points to negative spatial autocorrelation. In the former case, positive and negative values of Moran’s I indicate positive and negative spatial autocorrelation, respectively.\nThese tests require a spatial neighborhood graph for computation of the statistic. There are several ways to define spatial neighbors and the findSpatialNeighbors() function wraps all of the methods implemented in the spdep package. Below, we compute a k-nearest neighborhood graph. The dist_type = \"idw\" weights the edges of the graph by the inverse distance between neighbors.\n\ncolGraph(sfe, \"knn5\") &lt;- findSpatialNeighbors(\n  sfe, method = \"knearneigh\", dist_type = \"idw\", \n  k = 5, style = \"W\")\n\nWe will also save the most variable genes for use in the computations below.\n\ndec &lt;- modelGeneVar(sfe)\nhvgs &lt;- getTopHVGs(dec, n = 100)\n\nWe use the runUnivariate() function to compute the spatial autocorrelation metrics and save the results and save them in the SFE object. The mc type for each test implements a permutation test for each statistic and relies on the nsim argument for computing a p-value for the statistic.\n\nsfe &lt;- runUnivariate(\n  sfe, type = \"geary.mc\", features = hvgs, \n  colGraphName = \"knn5\", nsim = 100, BPPARAM = MulticoreParam(2))\n\n\nsfe &lt;- runUnivariate(\n  sfe, type = \"moran.mc\", features = hvgs,\n  colGraphName = \"knn5\", nsim = 100, BPPARAM = MulticoreParam(2))\n\nsfe &lt;- colDataUnivariate(\n  sfe, type = \"moran.mc\", features = c(\"nCounts\", \"nGenes\"), \n  colGraphName = \"knn5\", nsim = 100)\n\nWe can plot the results of the Monte Carlo simulations:\n\nplotMoranMC(sfe, \"Meox1\")\n\n\n\n\n\n\n\n\nThe vertical line represents the observed value of Moran’s I and the density represents Moran’s I computed from the permuted data. These simulations suggest that the spatial autocorrelation for this feature is significant.\nThe function can also be used to plot the geary.mc results.\nNow, we might ask: which genes display the most spatial autocorrelation?\n\ntop_moran &lt;- rownames(sfe)[order(-rowData(sfe)$moran.mc_statistic_sample01)[1:4]]\n\nplotSpatialFeature(sfe, top_moran, colGeometryName = \"seg_coords\")\n\n\n\n\n\n\n\n\nIt appears that the genes with the highest spatial autocorrelation seem to have obvious expression patterns in the tissue.\nIt would be interesting to see if these genes are also differentially expressed in the clusters above. Non-spatial differential gene expression can be interrogated using the findMarkers() function implemented in the scran package and more complex methods for identifying spatially variable genes are actively being developed.\nThese analyses bring up interesting considerations. For one, it is unclear whether normalization scheme employed here effectively removes FOV batch effects. That said, there may be times where FOV differences are expected and represent biological differences, for example in the context of a tumor sample. It remains to be seen what normalization methods will perform best in these cases, and this is represents an area for research.\n\n\nSession Info\n\nsessionInfo()\n#&gt; R version 4.5.2 (2025-10-31)\n#&gt; Platform: aarch64-apple-darwin20\n#&gt; Running under: macOS Sequoia 15.6.1\n#&gt; \n#&gt; Matrix products: default\n#&gt; BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib \n#&gt; LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n#&gt; \n#&gt; locale:\n#&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#&gt; \n#&gt; time zone: America/Los_Angeles\n#&gt; tzcode source: internal\n#&gt; \n#&gt; attached base packages:\n#&gt; [1] stats4    stats     graphics  grDevices utils     datasets  methods  \n#&gt; [8] base     \n#&gt; \n#&gt; other attached packages:\n#&gt;  [1] BiocParallel_1.44.0             spdep_1.4-1                    \n#&gt;  [3] sf_1.0-21                       spData_2.3.4                   \n#&gt;  [5] patchwork_1.3.2                 fossil_0.4.0                   \n#&gt;  [7] shapefiles_0.7.2                foreign_0.8-90                 \n#&gt;  [9] maps_3.4.3                      sp_2.2-0                       \n#&gt; [11] dplyr_1.1.4                     tidyr_1.3.1                    \n#&gt; [13] purrr_1.2.0                     bluster_1.20.0                 \n#&gt; [15] scran_1.38.0                    scater_1.38.0                  \n#&gt; [17] ggplot2_4.0.0                   scuttle_1.20.0                 \n#&gt; [19] batchelor_1.26.0                SpatialExperiment_1.20.0       \n#&gt; [21] SingleCellExperiment_1.32.0     SummarizedExperiment_1.40.0    \n#&gt; [23] Biobase_2.70.0                  GenomicRanges_1.62.0           \n#&gt; [25] Seqinfo_1.0.0                   IRanges_2.44.0                 \n#&gt; [27] S4Vectors_0.48.0                BiocGenerics_0.56.0            \n#&gt; [29] generics_0.1.4                  MatrixGenerics_1.22.0          \n#&gt; [31] matrixStats_1.5.0               SFEData_1.12.0                 \n#&gt; [33] Voyager_1.12.0                  SpatialFeatureExperiment_1.12.1\n#&gt; \n#&gt; loaded via a namespace (and not attached):\n#&gt;   [1] splines_4.5.2             bitops_1.0-9             \n#&gt;   [3] filelock_1.0.3            tibble_3.3.0             \n#&gt;   [5] R.oo_1.27.1               lifecycle_1.0.4          \n#&gt;   [7] httr2_1.2.1               edgeR_4.8.0              \n#&gt;   [9] lattice_0.22-7            MASS_7.3-65              \n#&gt;  [11] magrittr_2.0.4            limma_3.66.0             \n#&gt;  [13] rmarkdown_2.30            yaml_2.3.10              \n#&gt;  [15] metapod_1.18.0            cowplot_1.2.0            \n#&gt;  [17] DBI_1.2.3                 RColorBrewer_1.1-3       \n#&gt;  [19] ResidualMatrix_1.20.0     multcomp_1.4-29          \n#&gt;  [21] abind_1.4-8               spatialreg_1.4-2         \n#&gt;  [23] R.utils_2.13.0            RCurl_1.98-1.17          \n#&gt;  [25] TH.data_1.1-4             rappdirs_0.3.3           \n#&gt;  [27] sandwich_3.1-1            ggrepel_0.9.6            \n#&gt;  [29] irlba_2.3.5.1             terra_1.8-80             \n#&gt;  [31] units_1.0-0               RSpectra_0.16-2          \n#&gt;  [33] dqrng_0.4.1               DelayedMatrixStats_1.32.0\n#&gt;  [35] codetools_0.2-20          DropletUtils_1.30.0      \n#&gt;  [37] DelayedArray_0.36.0       tidyselect_1.2.1         \n#&gt;  [39] memuse_4.2-3              farver_2.1.2             \n#&gt;  [41] ScaledMatrix_1.18.0       viridis_0.6.5            \n#&gt;  [43] BiocFileCache_3.0.0       jsonlite_2.0.0           \n#&gt;  [45] BiocNeighbors_2.4.0       e1071_1.7-16             \n#&gt;  [47] survival_3.8-3            tools_4.5.2              \n#&gt;  [49] ggnewscale_0.5.2          Rcpp_1.1.0               \n#&gt;  [51] glue_1.8.0                gridExtra_2.3            \n#&gt;  [53] SparseArray_1.10.1        xfun_0.54                \n#&gt;  [55] EBImage_4.52.0            HDF5Array_1.38.0         \n#&gt;  [57] withr_3.0.2               BiocManager_1.30.26      \n#&gt;  [59] fastmap_1.2.0             boot_1.3-32              \n#&gt;  [61] rhdf5filters_1.22.0       digest_0.6.37            \n#&gt;  [63] rsvd_1.0.5                R6_2.6.1                 \n#&gt;  [65] wk_0.9.4                  LearnBayes_2.15.1        \n#&gt;  [67] jpeg_0.1-11               RSQLite_2.4.3            \n#&gt;  [69] R.methodsS3_1.8.2         h5mread_1.2.0            \n#&gt;  [71] data.table_1.17.8         class_7.3-23             \n#&gt;  [73] httr_1.4.7                htmlwidgets_1.6.4        \n#&gt;  [75] S4Arrays_1.10.0           pkgconfig_2.0.3          \n#&gt;  [77] scico_1.5.0               gtable_0.3.6             \n#&gt;  [79] blob_1.2.4                S7_0.2.0                 \n#&gt;  [81] XVector_0.50.0            htmltools_0.5.8.1        \n#&gt;  [83] fftwtools_0.9-11          scales_1.4.0             \n#&gt;  [85] png_0.1-8                 knitr_1.50               \n#&gt;  [87] rjson_0.2.23              coda_0.19-4.1            \n#&gt;  [89] nlme_3.1-168              curl_7.0.0               \n#&gt;  [91] proxy_0.4-27              cachem_1.1.0             \n#&gt;  [93] zoo_1.8-14                rhdf5_2.54.0             \n#&gt;  [95] BiocVersion_3.22.0        KernSmooth_2.23-26       \n#&gt;  [97] parallel_4.5.2            vipor_0.4.7              \n#&gt;  [99] AnnotationDbi_1.72.0      s2_1.1.9                 \n#&gt; [101] pillar_1.11.1             grid_4.5.2               \n#&gt; [103] vctrs_0.6.5               BiocSingular_1.26.0      \n#&gt; [105] dbplyr_2.5.1              beachmat_2.26.0          \n#&gt; [107] sfheaders_0.4.4           cluster_2.1.8.1          \n#&gt; [109] beeswarm_0.4.0            evaluate_1.0.5           \n#&gt; [111] zeallot_0.2.0             magick_2.9.0             \n#&gt; [113] mvtnorm_1.3-3             cli_3.6.5                \n#&gt; [115] locfit_1.5-9.12           compiler_4.5.2           \n#&gt; [117] rlang_1.1.6               crayon_1.5.3             \n#&gt; [119] labeling_0.4.3            classInt_0.4-11          \n#&gt; [121] ggbeeswarm_0.7.2          viridisLite_0.4.2        \n#&gt; [123] deldir_2.0-4              Biostrings_2.78.0        \n#&gt; [125] tiff_0.1-12               Matrix_1.7-4             \n#&gt; [127] ExperimentHub_3.0.0       sparseMatrixStats_1.22.0 \n#&gt; [129] bit64_4.6.0-1             Rhdf5lib_1.32.0          \n#&gt; [131] KEGGREST_1.50.0           statmod_1.5.1            \n#&gt; [133] AnnotationHub_4.0.0       igraph_2.2.1             \n#&gt; [135] memoise_2.0.1             bit_4.6.0"
  },
  {
    "objectID": "seqfish_pipeline.html",
    "href": "seqfish_pipeline.html",
    "title": "seqFISH exploratory data analysis",
    "section": "",
    "text": "Introduction\nIn this vignette, we will demonstrate an example analysis workflow for spatial transcriptomics data collected using the seqFISH technology. The analysis will cover quality control, normalization, dimension reduction, clustering, and univariate spatial statistics. The workflow will make use of functions implemented in the Voyager R package as well as other Bioconductor packages.\n\n\nDataset\nThe data used in this vignette are described in Integration of spatial and single-cell transcriptomic data elucidates mouse organogenesis. Briefly, seqFISH was use to profile 351 genes in several mouse embryos at the 8-12 somite stage (ss). We will focus on a single biological replicate, embryo 3. The raw and processed counts and corresponding metadata are available to download from the Marioni lab. Expression matrices, segmentation data, and segmented cell vertices are provided as R objects that can be readily imported into an R environment. The data relevant to this vignette have been converted to a SFE object and are available to download here from Box.\nThe data have been added to the SFEData package on Bioconductor and will be available in the release release.\nWe will begin by downloading the data and loading it in to R.\n\nlibrary(Voyager)\nlibrary(SFEData)\nlibrary(SingleCellExperiment)\nlibrary(SpatialExperiment)\nlibrary(SpatialFeatureExperiment)\nlibrary(batchelor)\nlibrary(scater)\nlibrary(scran)\nlibrary(bluster)\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(fossil)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(spdep)\nlibrary(BiocParallel)\n\ntheme_set(theme_bw())\n\n\n# Only Bioc release and above\nsfe &lt;- LohoffGastrulationData()\n#&gt; see ?SFEData and browseVignettes('SFEData') for documentation\n#&gt; loading from cache\n\nThe rows in the count matrix correspond to the 351 barcoded genes measured by seqFISH. Additionally, the authors provide some metadata, including the field of view and z-slice for each cell. We will filter the count matrix and metadata to include only cells from a single z-slice.\n\nnames(colData(sfe))\n#&gt;  [1] \"uniqueID\"                \"embryo\"                 \n#&gt;  [3] \"pos\"                     \"z\"                      \n#&gt;  [5] \"x_global\"                \"y_global\"               \n#&gt;  [7] \"x_global_affine\"         \"y_global_affine\"        \n#&gt;  [9] \"embryo_pos\"              \"embryo_pos_z\"           \n#&gt; [11] \"Area\"                    \"UMAP1\"                  \n#&gt; [13] \"UMAP2\"                   \"celltype_mapped_refined\"\n#&gt; [15] \"sample_id\"\n\n\nmask &lt;- colData(sfe)$z == 2\nsfe &lt;- sfe[,mask]\n\n\n\nQuality control\nWe will begin quality control (QC) of the cells by computing metrics that are common in single-cell analysis and store them in the colData field of the SFE object. Below, we compute the number of counts per cell. We will also compute the average and display it on the violin plot.\n\ncolData(sfe)$nCounts &lt;- colSums(counts(sfe))\navg &lt;- mean(colData(sfe)$nCounts)\n\nviolin &lt;- plotColData(sfe, \"nCounts\") +\n    geom_hline(yintercept = avg, color='red') +\n    theme(legend.position = \"top\") \n\nspatial &lt;- plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"seg_coords\")\n\nviolin + spatial\n\n\n\n\n\n\n\n\nNotably, the cells in this dataset have fewer counts than would be expected in a single-cell sequencing experiment and the cells with higher counts seem to be dispersed throughout the tissue. Fewer counts are expected in seqFISH experiments where probing for highly expressed genes may lead to optical crowding over multiple imaging rounds.\nSince the counts are collected from several fields of view, we will visualize the number of cells and total counts for each field separately.\n\npos &lt;- colData(sfe)$pos\ncounts_spl &lt;- split.data.frame(t(counts(sfe)), pos)\n\n# nCounts per FOV\ndf &lt;- map_dfr(counts_spl, rowSums, .id='pos') |&gt;\n    pivot_longer(cols=contains('embryo'), values_to = 'nCounts') |&gt;\n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    dplyr::filter(!is.na(nCounts))\n\ncells_fov &lt;- colData(sfe) |&gt; \n    as.data.frame() |&gt; \n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    ggplot(aes(pos,)) +\n    geom_bar() + \n    theme_minimal() + \n    labs(\n        x = \"\",\n        y = \"Number of cells\") + \n    theme(axis.text.x = element_text(angle = 90))\n\ncounts_fov &lt;- ggplot(df, aes(pos, nCounts)) +\n    geom_boxplot(outlier.size = 0.5) + \n    theme_minimal() + \n    labs(x = \"\", y = 'nCounts') + \n    theme(axis.text.x = element_text(angle = 90))\n\ncells_fov / counts_fov\n\n\n\n\n\n\n\n\nThere is some variability in the total number of counts in each field of view. It is not completely apparent what accounts for the low number of counts in some FOVs. For example, FOV 22 has the fewest number of cells, but comparably more counts are detected there than in regions with more cells (e.g. FOV 18).\nNext, will will compute the number of genes detected per cell, defined here as the number of genes with non-zero counts. We will again plot this metric for each FOV as is done above.\n\ncolData(sfe)$nGenes &lt;- colSums(counts(sfe) &gt; 0)\n\navg &lt;- mean(colData(sfe)$nGenes)\n\nviolin &lt;- plotColData(sfe, \"nGenes\") +\n    geom_hline(yintercept = avg, color='red') +\n    theme(legend.position = \"top\") \n\nspatial &lt;- plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"seg_coords\")\n\nviolin + spatial\n\n\n\n\n\n\n\n\nMany cells have fewer than 100 detected genes. This in part reflects that the panel of 351 probed genes was chosen to distinguish cell types at these developmental stages and that distinct cell types will likely express a small subset of the 351 genes. The authors also note that the gene panel consists of lowly expressed to moderately expressed genes. Taken together, these technical details can explain the relatively low number of counts and genes per cell.\nHere, we plot the number of genes detected per cell in each FOV.\n\ndf &lt;- map_dfr(counts_spl, ~ rowSums(.x &gt; 0), .id='pos') |&gt;\n    pivot_longer(cols = contains('embryo'), values_to = 'nGenes') |&gt;\n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    filter(!is.na(nGenes)) |&gt;\n    merge(df)\n\ngenes_fov &lt;- ggplot(df, aes(pos, nGenes)) +\n    geom_boxplot(outlier.size = 0.5) + \n    theme_bw() + \n    labs(x = \"\") + \n    theme(axis.text.x = element_text(angle = 90))\n\ngenes_fov\n\n\n\n\n\n\n\n\nThis plot mirrors the plot above for total counts. No single FOV stands out as an obvious outlier.\nThe authors have provided cell type assignments as metadata. We can assess whether the low quality cells tend to be located in a particular FOV.\n\nmeta &lt;- data.frame(colData(sfe)) \n\nmeta &lt;- meta |&gt; \n    group_by(pos) |&gt; \n    add_tally(name = \"nCells_FOV\") |&gt; \n    filter(celltype_mapped_refined %in% \"Low quality\") |&gt; \n    add_tally(name = \"nLQ_FOV\") |&gt; \n    mutate(prop_lq = nLQ_FOV/nCells_FOV) |&gt;\n    distinct(pos, prop_lq) |&gt; \n    ungroup() |&gt; \n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1)))\n\nprop_lq &lt;- ggplot(meta, aes(pos, prop_lq)) + \n    geom_bar(stat = 'identity' ) + \n    theme(axis.text.x = element_text(angle = 90)) \n\nprop_lq\n\n\n\n\n\n\n\n\nIt appears that FOV 26 and 31 have the largest fraction of low quality cells. Interestingly, these do not correspond to the FOVs with the largest number of cells overall.\nHere we plot nCounts vs. nGenes for each FOV.\n\ncount_vs_genes_p &lt;- ggplot(df, aes(nCounts, nGenes)) + \n  geom_point(\n    alpha = 0.5,\n    size = 1,\n    fill = \"white\"\n  ) +\n  facet_wrap(~ pos)\n\ncount_vs_genes_p \n\n\n\n\n\n\n\n\nAs in scRNA-seq, gene expression variance in seqFISH measurements is overdispersed compared to variance of counts that are Poisson distributed.\n\ngene_meta &lt;- map_dfr(counts_spl, colMeans, .id = 'pos') |&gt; \n  pivot_longer(cols = -pos, names_to = 'gene', values_to = 'mean')\n\ngene_meta &lt;- map_dfr(counts_spl, ~colVars(.x, useNames = TRUE), .id = 'pos') |&gt; \n  pivot_longer(-pos, names_to = 'gene', values_to='variance') |&gt; \n  full_join(gene_meta)\n#&gt; Joining with `by = join_by(pos, gene)`\n\nTo understand the mean-variance relationship, we compute the mean and variance for each gene among cells in tissue. As above, we will perform this calculation separately for each FOV\n\nggplot(gene_meta, aes(mean, variance)) + \n  geom_point(\n    alpha = 0.5,\n    size = 1,\n    fill = \"white\"\n  ) +\n  facet_wrap(~ pos) +\n  geom_abline(slope = 1, intercept = 0, color = \"red\") +\n  scale_x_log10() + scale_y_log10() +\n  annotation_logticks()\n\n\n\n\n\n\n\n\nThe red line represents the line \\(y = x\\), which is the mean-variance relationship that would be expected for Poisson distributed data. The data deviate from this expectation in each FOV. In each case, the variance is greater than what would be expected.\n\n\nData normalization and dimension reduction\nThe exploratory analysis above indicates the presence of batch effects corresponding to FOV. We will use a normalization scheme that is batch aware. As the SFE object inherits from the SpatialExperimentand SingleCellExperiment, classes, we can take advantage of normalization methods implemented in the scran and batchelor R packages.\nWe will first use the multiBatchNorm() function to scale the data within each batch. As noted in the documentation, the function uses median-based normalization on the ratio of the average counts between batches.\nBatch correction and dimension reduction is accomplished using fastMNN() which performs multi-sample PCA across multiple gene expression matrices to project all cells to a common low-dimensional space.\n\nsfe &lt;- multiBatchNorm(sfe, batch = pos)\nsfe_red &lt;- fastMNN(sfe, batch = pos, cos.norm = FALSE, d = 20)\n\nThe function fastMNN returns a batch-corrected matrix in the reducedDims slot of a SingleCellExperiment object. We will extract the relevant data and store them in the SFE ojbject.\n\nreducedDim(sfe, \"PCA\") &lt;- reducedDim(sfe_red, \"corrected\")\nassay(sfe, \"reconstructed\") &lt;- assay(sfe_red, \"reconstructed\") \n\nNow we will visualize the first two PCs in space. Here we notice that the PCs may show some spatial structure that correlates to biological niches of cells.\n\nspatialReducedDim(sfe, \"PCA\", ncomponents = 2, divergent = TRUE, diverge_center = 0)\n\n\n\n\n\n\n\n\nUnfortunately, FOV artifacts can still be seen.\n\n\nClustering\nMuch like in single cell analysis, we can use the batch-corrected data to cluster the cells. We will implement a graph-based clustering algorithm and plot the resulting clusters in space.\n\ncolData(sfe)$cluster &lt;- \n  clusterRows(reducedDim(sfe, \"PCA\"),\n                      BLUSPARAM = SNNGraphParam(\n                        cluster.fun = \"leiden\",\n                        cluster.args = list(\n                        resolution_parameter = 0.5,\n                        objective_function = \"modularity\")\n                        )\n              )\n\nThe plot below is colored by cluster ID and by the cell types provided by the author.\n\nplotSpatialFeature(sfe, c(\"cluster\", \"celltype_mapped_refined\"), \n                   colGeometryName = \"seg_coords\")\n\n\n\n\n\n\n\n\nThe authors have assigned cells to more types than are identified in the clustering step. In any case, the clustering results seem to recapitulate the major cell niches from the previous annotations. We can compute the Rand index using a function from the fossil package to assess the similarity between the two clustering results. A value of 1 would suggest the clustering results are identical, while a value of 0 would suggest that the results do not agree at all.\n\ng1 &lt;- as.numeric(colData(sfe)$cluster)\ng2 &lt;- as.numeric(colData(sfe)$celltype_mapped_refined)\n\nrand.index(g1, g2)\n#&gt; [1] 0.8466965\n\nThe relatively large Rand index suggests that cells are often found in the same cluster in both cases.\n\n\nUnivariate Spatial Statistics\nAt this point, we may be interested in identifying genes that exhibit spatial variability, or whose expression depends on spatial location within the tissue. Measures of spatial autocorrelation can be useful in identifyign genes that display spatial variablity. Among the most common measures are Moran’s I and Geary’s C. In the latter case, a less than 1 indicates positive spatial autocorrelation, while a value larger than 1 points to negative spatial autocorrelation. In the former case, positive and negative values of Moran’s I indicate positive and negative spatial autocorrelation, respectively.\nThese tests require a spatial neighborhood graph for computation of the statistic. There are several ways to define spatial neighbors and the findSpatialNeighbors() function wraps all of the methods implemented in the spdep package. Below, we compute a k-nearest neighborhood graph. The dist_type = \"idw\" weights the edges of the graph by the inverse distance between neighbors.\n\ncolGraph(sfe, \"knn5\") &lt;- findSpatialNeighbors(\n  sfe, method = \"knearneigh\", dist_type = \"idw\", \n  k = 5, style = \"W\")\n\nWe will also save the most variable genes for use in the computations below.\n\ndec &lt;- modelGeneVar(sfe)\nhvgs &lt;- getTopHVGs(dec, n = 100)\n\nWe use the runUnivariate() function to compute the spatial autocorrelation metrics and save the results and save them in the SFE object. The mc type for each test implements a permutation test for each statistic and relies on the nsim argument for computing a p-value for the statistic.\n\nsfe &lt;- runUnivariate(\n  sfe, type = \"geary.mc\", features = hvgs, \n  colGraphName = \"knn5\", nsim = 100, BPPARAM = MulticoreParam(2))\n\n\nsfe &lt;- runUnivariate(\n  sfe, type = \"moran.mc\", features = hvgs,\n  colGraphName = \"knn5\", nsim = 100, BPPARAM = MulticoreParam(2))\n\nsfe &lt;- colDataUnivariate(\n  sfe, type = \"moran.mc\", features = c(\"nCounts\", \"nGenes\"), \n  colGraphName = \"knn5\", nsim = 100)\n\nWe can plot the results of the Monte Carlo simulations:\n\nplotMoranMC(sfe, \"Meox1\")\n\n\n\n\n\n\n\n\nThe vertical line represents the observed value of Moran’s I and the density represents Moran’s I computed from the permuted data. These simulations suggest that the spatial autocorrelation for this feature is significant.\nThe function can also be used to plot the geary.mc results.\nNow, we might ask: which genes display the most spatial autocorrelation?\n\ntop_moran &lt;- rownames(sfe)[order(-rowData(sfe)$moran.mc_statistic_sample01)[1:4]]\n\nplotSpatialFeature(sfe, top_moran, colGeometryName = \"seg_coords\")\n\n\n\n\n\n\n\n\nIt appears that the genes with the highest spatial autocorrelation seem to have obvious expression patterns in the tissue.\nIt would be interesting to see if these genes are also differentially expressed in the clusters above. Non-spatial differential gene expression can be interrogated using the findMarkers() function implemented in the scran package and more complex methods for identifying spatially variable genes are actively being developed.\nThese analyses bring up interesting considerations. For one, it is unclear whether normalization scheme employed here effectively removes FOV batch effects. That said, there may be times where FOV differences are expected and represent biological differences, for example in the context of a tumor sample. It remains to be seen what normalization methods will perform best in these cases, and this is represents an area for research.\n\n\nSession Info\n\nsessionInfo()\n#&gt; R version 4.5.2 (2025-10-31)\n#&gt; Platform: aarch64-apple-darwin20\n#&gt; Running under: macOS Sequoia 15.6.1\n#&gt; \n#&gt; Matrix products: default\n#&gt; BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib \n#&gt; LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n#&gt; \n#&gt; locale:\n#&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#&gt; \n#&gt; time zone: America/Los_Angeles\n#&gt; tzcode source: internal\n#&gt; \n#&gt; attached base packages:\n#&gt; [1] stats4    stats     graphics  grDevices utils     datasets  methods  \n#&gt; [8] base     \n#&gt; \n#&gt; other attached packages:\n#&gt;  [1] BiocParallel_1.44.0             spdep_1.4-1                    \n#&gt;  [3] sf_1.0-21                       spData_2.3.4                   \n#&gt;  [5] patchwork_1.3.2                 fossil_0.4.0                   \n#&gt;  [7] shapefiles_0.7.2                foreign_0.8-90                 \n#&gt;  [9] maps_3.4.3                      sp_2.2-0                       \n#&gt; [11] dplyr_1.1.4                     tidyr_1.3.1                    \n#&gt; [13] purrr_1.2.0                     bluster_1.20.0                 \n#&gt; [15] scran_1.38.0                    scater_1.38.0                  \n#&gt; [17] ggplot2_4.0.0                   scuttle_1.20.0                 \n#&gt; [19] batchelor_1.26.0                SpatialExperiment_1.20.0       \n#&gt; [21] SingleCellExperiment_1.32.0     SummarizedExperiment_1.40.0    \n#&gt; [23] Biobase_2.70.0                  GenomicRanges_1.62.0           \n#&gt; [25] Seqinfo_1.0.0                   IRanges_2.44.0                 \n#&gt; [27] S4Vectors_0.48.0                BiocGenerics_0.56.0            \n#&gt; [29] generics_0.1.4                  MatrixGenerics_1.22.0          \n#&gt; [31] matrixStats_1.5.0               SFEData_1.12.0                 \n#&gt; [33] Voyager_1.12.0                  SpatialFeatureExperiment_1.12.1\n#&gt; \n#&gt; loaded via a namespace (and not attached):\n#&gt;   [1] splines_4.5.2             bitops_1.0-9             \n#&gt;   [3] filelock_1.0.3            tibble_3.3.0             \n#&gt;   [5] R.oo_1.27.1               lifecycle_1.0.4          \n#&gt;   [7] httr2_1.2.1               edgeR_4.8.0              \n#&gt;   [9] lattice_0.22-7            MASS_7.3-65              \n#&gt;  [11] magrittr_2.0.4            limma_3.66.0             \n#&gt;  [13] rmarkdown_2.30            yaml_2.3.10              \n#&gt;  [15] metapod_1.18.0            cowplot_1.2.0            \n#&gt;  [17] DBI_1.2.3                 RColorBrewer_1.1-3       \n#&gt;  [19] ResidualMatrix_1.20.0     multcomp_1.4-29          \n#&gt;  [21] abind_1.4-8               spatialreg_1.4-2         \n#&gt;  [23] R.utils_2.13.0            RCurl_1.98-1.17          \n#&gt;  [25] TH.data_1.1-4             rappdirs_0.3.3           \n#&gt;  [27] sandwich_3.1-1            ggrepel_0.9.6            \n#&gt;  [29] irlba_2.3.5.1             terra_1.8-80             \n#&gt;  [31] units_1.0-0               RSpectra_0.16-2          \n#&gt;  [33] dqrng_0.4.1               DelayedMatrixStats_1.32.0\n#&gt;  [35] codetools_0.2-20          DropletUtils_1.30.0      \n#&gt;  [37] DelayedArray_0.36.0       tidyselect_1.2.1         \n#&gt;  [39] memuse_4.2-3              farver_2.1.2             \n#&gt;  [41] ScaledMatrix_1.18.0       viridis_0.6.5            \n#&gt;  [43] BiocFileCache_3.0.0       jsonlite_2.0.0           \n#&gt;  [45] BiocNeighbors_2.4.0       e1071_1.7-16             \n#&gt;  [47] survival_3.8-3            tools_4.5.2              \n#&gt;  [49] ggnewscale_0.5.2          Rcpp_1.1.0               \n#&gt;  [51] glue_1.8.0                gridExtra_2.3            \n#&gt;  [53] SparseArray_1.10.1        xfun_0.54                \n#&gt;  [55] EBImage_4.52.0            HDF5Array_1.38.0         \n#&gt;  [57] withr_3.0.2               BiocManager_1.30.26      \n#&gt;  [59] fastmap_1.2.0             boot_1.3-32              \n#&gt;  [61] rhdf5filters_1.22.0       digest_0.6.37            \n#&gt;  [63] rsvd_1.0.5                R6_2.6.1                 \n#&gt;  [65] wk_0.9.4                  LearnBayes_2.15.1        \n#&gt;  [67] jpeg_0.1-11               RSQLite_2.4.3            \n#&gt;  [69] R.methodsS3_1.8.2         h5mread_1.2.0            \n#&gt;  [71] data.table_1.17.8         class_7.3-23             \n#&gt;  [73] httr_1.4.7                htmlwidgets_1.6.4        \n#&gt;  [75] S4Arrays_1.10.0           pkgconfig_2.0.3          \n#&gt;  [77] scico_1.5.0               gtable_0.3.6             \n#&gt;  [79] blob_1.2.4                S7_0.2.0                 \n#&gt;  [81] XVector_0.50.0            htmltools_0.5.8.1        \n#&gt;  [83] fftwtools_0.9-11          scales_1.4.0             \n#&gt;  [85] png_0.1-8                 knitr_1.50               \n#&gt;  [87] rjson_0.2.23              coda_0.19-4.1            \n#&gt;  [89] nlme_3.1-168              curl_7.0.0               \n#&gt;  [91] proxy_0.4-27              cachem_1.1.0             \n#&gt;  [93] zoo_1.8-14                rhdf5_2.54.0             \n#&gt;  [95] BiocVersion_3.22.0        KernSmooth_2.23-26       \n#&gt;  [97] parallel_4.5.2            vipor_0.4.7              \n#&gt;  [99] AnnotationDbi_1.72.0      s2_1.1.9                 \n#&gt; [101] pillar_1.11.1             grid_4.5.2               \n#&gt; [103] vctrs_0.6.5               BiocSingular_1.26.0      \n#&gt; [105] dbplyr_2.5.1              beachmat_2.26.0          \n#&gt; [107] sfheaders_0.4.4           cluster_2.1.8.1          \n#&gt; [109] beeswarm_0.4.0            evaluate_1.0.5           \n#&gt; [111] zeallot_0.2.0             magick_2.9.0             \n#&gt; [113] mvtnorm_1.3-3             cli_3.6.5                \n#&gt; [115] locfit_1.5-9.12           compiler_4.5.2           \n#&gt; [117] rlang_1.1.6               crayon_1.5.3             \n#&gt; [119] labeling_0.4.3            classInt_0.4-11          \n#&gt; [121] ggbeeswarm_0.7.2          viridisLite_0.4.2        \n#&gt; [123] deldir_2.0-4              Biostrings_2.78.0        \n#&gt; [125] tiff_0.1-12               Matrix_1.7-4             \n#&gt; [127] ExperimentHub_3.0.0       sparseMatrixStats_1.22.0 \n#&gt; [129] bit64_4.6.0-1             Rhdf5lib_1.32.0          \n#&gt; [131] KEGGREST_1.50.0           statmod_1.5.1            \n#&gt; [133] AnnotationHub_4.0.0       igraph_2.2.1             \n#&gt; [135] memoise_2.0.1             bit_4.6.0"
  }
]