[
  {
    "objectID": "seqspec.html",
    "href": "seqspec.html",
    "title": "What is seqspec?",
    "section": "",
    "text": "seqspec is a simple, standardized file format to describe how a genomics library was prepared and sequenced. Different genomics assays require unique processing steps. Including a seqspec file with your data makes it easy for others (and future you!) to reanalyze your dataset. Here we will give a brief description of the seqspec format. For a more in-depth description of seqspec and the seqspec file format, refer to the GitHub page."
  },
  {
    "objectID": "seqspec.html#understanding-the-seqspec-file-format",
    "href": "seqspec.html#understanding-the-seqspec-file-format",
    "title": "What is seqspec?",
    "section": "Understanding the seqspec File Format",
    "text": "Understanding the seqspec File Format\nA seqspec file is a YAML-formatted document with three main sections:\n\nAssay Info – metadata describing the assay and protocols used\n\nLibrary Structure – layout and sequence of regions in the library\n\nRead Structure – how the sequencing reads correspond to library regions\n\nEach section depends on the specific library preparation and sequencing technology used in your assay.\n\n\n\n\n\n\nNoteWhy YAML?\n\n\n\nYAML (short for “YAML Ain’t Markup Language”) is a lightweight, human-readable format that is easy to edit and interpret, yet structured enough for automated parsing by software. This balance makes it ideal for encoding experimental metadata that must be both transparent to researchers and machine-accessible for reproducible analysis."
  },
  {
    "objectID": "seqspec.html#section-1-assay-info",
    "href": "seqspec.html#section-1-assay-info",
    "title": "What is seqspec?",
    "section": "Section 1: Assay Info",
    "text": "Section 1: Assay Info\nThe first section describes the overall experiment — what assay was used, which kit, and how it was sequenced.\n\nBasic Format\n!Assay\nseqspec_version: 0.3.0\nassay_id: \nname: \ndoi: \ndate: \ndescription:\nmodalities: rna\nlib_struct: \nsequence_protocol: \nsequence_kit: \nlibrary_protocol: \nlibrary_kit:\nseqspec_version — version of the seqspec format used (this tutorial will use version 0.3.0)\nassay_id, name, doi, date, description — metadata describing the assay\nlibrary_protocol, library_kit — kit and reagents used for library prep\nsequence_protocol, sequence_kit — sequencing instrument and reagents used\n\n\nExample\nSuppose you used the Parse Biosciences Evercode WT Mega v2.0.1 dual index kit to generate an scRNA-seq library, sequenced on Illumina NovaSeq X. The corresponding seqspec file might look like so:\n!Assay\nseqspec_version: 0.3.0\nassay_id: Evercode-WT-mega-v2-dual-index\nname: Parse Evercode Mega WT v2 using dual Illumina multiplex index\ndoi: https://www.protocols.io/view/evercode-wt-mega-v2-2-1-8epv5xxrng1b/v1?step=21\ndate: 08 November 2023\ndescription: split-pool ligation-based transcriptome sequencing\nmodalities: rna\nlib_struct: https://igvf.github.io/seqspec/\nlibrary_protocol: single-nucleus RNA sequencing assay (OBI:0003109)\nlibrary_kit: Evercode WT Mega v2.0.1 dual index\nsequence_protocol: Illumina NovaSeq X (EFO:0022840)\nsequence_kit: NovaSeq X Series 25B Reagent Kit"
  },
  {
    "objectID": "seqspec.html#section-2-library-structure",
    "href": "seqspec.html#section-2-library-structure",
    "title": "What is seqspec?",
    "section": "Section 2: Library Structure",
    "text": "Section 2: Library Structure\nThe library structure section lists all regions in the sequencing library (from 5’ to 3’), such as primers, linkers, UMIs, and barcodes.\nEach region is defined with the following template:\n- !Region\n  parent_id: \n  region_id: \n  region_type:\n  name: \n  sequence_type: \n  sequence: \n  min_len: \n  max_len: \n  onlist: \n  regions: \nregion_id, region_type, name — identifies and describes the region\nparent_id — refers to the parent region (if it exists)\nsequence, sequence_type — specifies the nucleotide sequence and its type (e.g., fixed, onlist, variable)\nmin_len, max_len — defines expected sequence lengths\nonlist — references a file or list of valid sequences (e.g., known cell barcodes)\n\nNested Regions\nParent regions can contain multiple child regions, forming a hierarchical structure. Here’s a minimal example with one parent and two child regions:\nlibrary_spec:\n- !Region\n  parent_id: null\n  region_id: parent\n  ...\n  regions:\n  - !Region\n    parent_id: parent\n    region_id: region_1\n    ...\n    regions: null\n  - !Region\n    parent_id: parent\n    region_id: region_2\n    ...\n    regions: null\n\n\nExamples\nBelow are two example regions you might find in a seqspec file.\n\nExample 1: Illumina P5 primer\n- !Region\n  parent_id: null\n  region_id: P5\n  region_type: primer\n  name: P5\n  sequence_type: fixed\n  sequence: AATGATACGGCGACCACCGAGATCTACAC\n  min_len: 29\n  max_len: 29\n  onlist: null\n  regions: null\n\n\nExample 2: Parse Biosciences Evercode WT cell barcode\n- !Region\n  parent_id: null\n  region_id: BC\n  region_type: barcode\n  name: cell barcode\n  sequence_type: onlist\n  sequence: NNNNNNNNNNNNNNNN\n  min_len: 16\n  max_len: 16\n  onlist: !Onlist\n    location: local\n    filename: onlist.txt\n  regions: null\n\n\n\n\n\n\nNoteWhat is an Onlist?\n\n\n\nIn Parse Evercode libraries, barcode regions are validated against a fixed list of known barcodes called the “onlist”."
  },
  {
    "objectID": "seqspec.html#section-3-read-structure",
    "href": "seqspec.html#section-3-read-structure",
    "title": "What is seqspec?",
    "section": "Section 3: Read Structure",
    "text": "Section 3: Read Structure\nThe read structure section links your FASTQ files to specific sequencing reads.\nEach read entry looks like this:\n- !Read\n  read_id: \n  name: \n  modality: \n  primer_id: \n  min_len: \n  max_len: \n  strand: \n  files:\nread_id, name — identifies the read object\nprimer_id — links to the corresponding primer region\nstrand — direction of sequencing relative to the library layout\nmin_len, max_len — expected read length\nfiles — references the FASTQ files containing this read\n\nExample\nsequence_spec:\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 28\n  max_len: 28\n  strand: pos\n  files:\n  - !File\n    file_id: read_1\n    filename: read_1.fastq.gz\n    filetype: fastq.gz\n    filesize: 10 GB\n    url: https://example.org/read_1.fastq.gz\n    urltype: https\n    md5: d1410f93b53357d4f95edb0ba0d73c07\n\n\nStep 3: Validate Your seqspec file with seqspec check\nYou can use seqspec check command from the seqspec package to verify your seqspec file is correctly formatted.\nseqspec check seqspec.yaml\nIf your file is valid, the command will complete without errors; otherwise, it will print a description of any issues found in the specification.\n\n\n\n\n\n\nNoteInstall seqspec\n\n\n\nIn order to install seqspec, follow our installation instructions here."
  },
  {
    "objectID": "seqfish_pipeline.html",
    "href": "seqfish_pipeline.html",
    "title": "seqFISH exploratory data analysis",
    "section": "",
    "text": "Introduction\nIn this vignette, we will demonstrate an example analysis workflow for spatial transcriptomics data collected using the seqFISH technology. The analysis will cover quality control, normalization, dimension reduction, clustering, and univariate spatial statistics. The workflow will make use of functions implemented in the Voyager R package as well as other Bioconductor packages.\n\n\nDataset\nThe data used in this vignette are described in Integration of spatial and single-cell transcriptomic data elucidates mouse organogenesis. Briefly, seqFISH was use to profile 351 genes in several mouse embryos at the 8-12 somite stage (ss). We will focus on a single biological replicate, embryo 3. The raw and processed counts and corresponding metadata are available to download from the Marioni lab. Expression matrices, segmentation data, and segmented cell vertices are provided as R objects that can be readily imported into an R environment. The data relevant to this vignette have been converted to a SFE object and are available to download here from Box.\nThe data have been added to the SFEData package on Bioconductor and will be available in the release release.\nWe will begin by downloading the data and loading it in to R.\n\nlibrary(Voyager)\nlibrary(SFEData)\nlibrary(SingleCellExperiment)\nlibrary(SpatialExperiment)\nlibrary(SpatialFeatureExperiment)\nlibrary(batchelor)\nlibrary(scater)\nlibrary(scran)\nlibrary(bluster)\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(fossil)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(spdep)\nlibrary(BiocParallel)\n\ntheme_set(theme_bw())\n\n\n# Only Bioc release and above\nsfe &lt;- LohoffGastrulationData()\n#&gt; see ?SFEData and browseVignettes('SFEData') for documentation\n#&gt; loading from cache\n\nThe rows in the count matrix correspond to the 351 barcoded genes measured by seqFISH. Additionally, the authors provide some metadata, including the field of view and z-slice for each cell. We will filter the count matrix and metadata to include only cells from a single z-slice.\n\nnames(colData(sfe))\n#&gt;  [1] \"uniqueID\"                \"embryo\"                 \n#&gt;  [3] \"pos\"                     \"z\"                      \n#&gt;  [5] \"x_global\"                \"y_global\"               \n#&gt;  [7] \"x_global_affine\"         \"y_global_affine\"        \n#&gt;  [9] \"embryo_pos\"              \"embryo_pos_z\"           \n#&gt; [11] \"Area\"                    \"UMAP1\"                  \n#&gt; [13] \"UMAP2\"                   \"celltype_mapped_refined\"\n#&gt; [15] \"sample_id\"\n\n\nmask &lt;- colData(sfe)$z == 2\nsfe &lt;- sfe[,mask]\n\n\n\nQuality control\nWe will begin quality control (QC) of the cells by computing metrics that are common in single-cell analysis and store them in the colData field of the SFE object. Below, we compute the number of counts per cell. We will also compute the average and display it on the violin plot.\n\ncolData(sfe)$nCounts &lt;- colSums(counts(sfe))\navg &lt;- mean(colData(sfe)$nCounts)\n\nviolin &lt;- plotColData(sfe, \"nCounts\") +\n    geom_hline(yintercept = avg, color='red') +\n    theme(legend.position = \"top\") \n\nspatial &lt;- plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"seg_coords\")\n\nviolin + spatial\n\n\n\n\n\n\n\n\nNotably, the cells in this dataset have fewer counts than would be expected in a single-cell sequencing experiment and the cells with higher counts seem to be dispersed throughout the tissue. Fewer counts are expected in seqFISH experiments where probing for highly expressed genes may lead to optical crowding over multiple imaging rounds.\nSince the counts are collected from several fields of view, we will visualize the number of cells and total counts for each field separately.\n\npos &lt;- colData(sfe)$pos\ncounts_spl &lt;- split.data.frame(t(counts(sfe)), pos)\n\n# nCounts per FOV\ndf &lt;- map_dfr(counts_spl, rowSums, .id='pos') |&gt;\n    pivot_longer(cols=contains('embryo'), values_to = 'nCounts') |&gt;\n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    dplyr::filter(!is.na(nCounts))\n\ncells_fov &lt;- colData(sfe) |&gt; \n    as.data.frame() |&gt; \n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    ggplot(aes(pos,)) +\n    geom_bar() + \n    theme_minimal() + \n    labs(\n        x = \"\",\n        y = \"Number of cells\") + \n    theme(axis.text.x = element_text(angle = 90))\n\ncounts_fov &lt;- ggplot(df, aes(pos, nCounts)) +\n    geom_boxplot(outlier.size = 0.5) + \n    theme_minimal() + \n    labs(x = \"\", y = 'nCounts') + \n    theme(axis.text.x = element_text(angle = 90))\n\ncells_fov / counts_fov\n\n\n\n\n\n\n\n\nThere is some variability in the total number of counts in each field of view. It is not completely apparent what accounts for the low number of counts in some FOVs. For example, FOV 22 has the fewest number of cells, but comparably more counts are detected there than in regions with more cells (e.g. FOV 18).\nNext, will will compute the number of genes detected per cell, defined here as the number of genes with non-zero counts. We will again plot this metric for each FOV as is done above.\n\ncolData(sfe)$nGenes &lt;- colSums(counts(sfe) &gt; 0)\n\navg &lt;- mean(colData(sfe)$nGenes)\n\nviolin &lt;- plotColData(sfe, \"nGenes\") +\n    geom_hline(yintercept = avg, color='red') +\n    theme(legend.position = \"top\") \n\nspatial &lt;- plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"seg_coords\")\n\nviolin + spatial\n\n\n\n\n\n\n\n\nMany cells have fewer than 100 detected genes. This in part reflects that the panel of 351 probed genes was chosen to distinguish cell types at these developmental stages and that distinct cell types will likely express a small subset of the 351 genes. The authors also note that the gene panel consists of lowly expressed to moderately expressed genes. Taken together, these technical details can explain the relatively low number of counts and genes per cell.\nHere, we plot the number of genes detected per cell in each FOV.\n\ndf &lt;- map_dfr(counts_spl, ~ rowSums(.x &gt; 0), .id='pos') |&gt;\n    pivot_longer(cols = contains('embryo'), values_to = 'nGenes') |&gt;\n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |&gt; \n    filter(!is.na(nGenes)) |&gt;\n    merge(df)\n\ngenes_fov &lt;- ggplot(df, aes(pos, nGenes)) +\n    geom_boxplot(outlier.size = 0.5) + \n    theme_bw() + \n    labs(x = \"\") + \n    theme(axis.text.x = element_text(angle = 90))\n\ngenes_fov\n\n\n\n\n\n\n\n\nThis plot mirrors the plot above for total counts. No single FOV stands out as an obvious outlier.\nThe authors have provided cell type assignments as metadata. We can assess whether the low quality cells tend to be located in a particular FOV.\n\nmeta &lt;- data.frame(colData(sfe)) \n\nmeta &lt;- meta |&gt; \n    group_by(pos) |&gt; \n    add_tally(name = \"nCells_FOV\") |&gt; \n    filter(celltype_mapped_refined %in% \"Low quality\") |&gt; \n    add_tally(name = \"nLQ_FOV\") |&gt; \n    mutate(prop_lq = nLQ_FOV/nCells_FOV) |&gt;\n    distinct(pos, prop_lq) |&gt; \n    ungroup() |&gt; \n    mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1)))\n\nprop_lq &lt;- ggplot(meta, aes(pos, prop_lq)) + \n    geom_bar(stat = 'identity' ) + \n    theme(axis.text.x = element_text(angle = 90)) \n\nprop_lq\n\n\n\n\n\n\n\n\nIt appears that FOV 26 and 31 have the largest fraction of low quality cells. Interestingly, these do not correspond to the FOVs with the largest number of cells overall.\nHere we plot nCounts vs. nGenes for each FOV.\n\ncount_vs_genes_p &lt;- ggplot(df, aes(nCounts, nGenes)) + \n  geom_point(\n    alpha = 0.5,\n    size = 1,\n    fill = \"white\"\n  ) +\n  facet_wrap(~ pos)\n\ncount_vs_genes_p \n\n\n\n\n\n\n\n\nAs in scRNA-seq, gene expression variance in seqFISH measurements is overdispersed compared to variance of counts that are Poisson distributed.\n\ngene_meta &lt;- map_dfr(counts_spl, colMeans, .id = 'pos') |&gt; \n  pivot_longer(cols = -pos, names_to = 'gene', values_to = 'mean')\n\ngene_meta &lt;- map_dfr(counts_spl, ~colVars(.x, useNames = TRUE), .id = 'pos') |&gt; \n  pivot_longer(-pos, names_to = 'gene', values_to='variance') |&gt; \n  full_join(gene_meta)\n#&gt; Joining with `by = join_by(pos, gene)`\n\nTo understand the mean-variance relationship, we compute the mean and variance for each gene among cells in tissue. As above, we will perform this calculation separately for each FOV\n\nggplot(gene_meta, aes(mean, variance)) + \n  geom_point(\n    alpha = 0.5,\n    size = 1,\n    fill = \"white\"\n  ) +\n  facet_wrap(~ pos) +\n  geom_abline(slope = 1, intercept = 0, color = \"red\") +\n  scale_x_log10() + scale_y_log10() +\n  annotation_logticks()\n\n\n\n\n\n\n\n\nThe red line represents the line \\(y = x\\), which is the mean-variance relationship that would be expected for Poisson distributed data. The data deviate from this expectation in each FOV. In each case, the variance is greater than what would be expected.\n\n\nData normalization and dimension reduction\nThe exploratory analysis above indicates the presence of batch effects corresponding to FOV. We will use a normalization scheme that is batch aware. As the SFE object inherits from the SpatialExperimentand SingleCellExperiment, classes, we can take advantage of normalization methods implemented in the scran and batchelor R packages.\nWe will first use the multiBatchNorm() function to scale the data within each batch. As noted in the documentation, the function uses median-based normalization on the ratio of the average counts between batches.\nBatch correction and dimension reduction is accomplished using fastMNN() which performs multi-sample PCA across multiple gene expression matrices to project all cells to a common low-dimensional space.\n\nsfe &lt;- multiBatchNorm(sfe, batch = pos)\nsfe_red &lt;- fastMNN(sfe, batch = pos, cos.norm = FALSE, d = 20)\n\nThe function fastMNN returns a batch-corrected matrix in the reducedDims slot of a SingleCellExperiment object. We will extract the relevant data and store them in the SFE ojbject.\n\nreducedDim(sfe, \"PCA\") &lt;- reducedDim(sfe_red, \"corrected\")\nassay(sfe, \"reconstructed\") &lt;- assay(sfe_red, \"reconstructed\") \n\nNow we will visualize the first two PCs in space. Here we notice that the PCs may show some spatial structure that correlates to biological niches of cells.\n\nspatialReducedDim(sfe, \"PCA\", ncomponents = 2, divergent = TRUE, diverge_center = 0)\n\n\n\n\n\n\n\n\nUnfortunately, FOV artifacts can still be seen.\n\n\nClustering\nMuch like in single cell analysis, we can use the batch-corrected data to cluster the cells. We will implement a graph-based clustering algorithm and plot the resulting clusters in space.\n\ncolData(sfe)$cluster &lt;- \n  clusterRows(reducedDim(sfe, \"PCA\"),\n                      BLUSPARAM = SNNGraphParam(\n                        cluster.fun = \"leiden\",\n                        cluster.args = list(\n                        resolution_parameter = 0.5,\n                        objective_function = \"modularity\")\n                        )\n              )\n\nThe plot below is colored by cluster ID and by the cell types provided by the author.\n\nplotSpatialFeature(sfe, c(\"cluster\", \"celltype_mapped_refined\"), \n                   colGeometryName = \"seg_coords\")\n\n\n\n\n\n\n\n\nThe authors have assigned cells to more types than are identified in the clustering step. In any case, the clustering results seem to recapitulate the major cell niches from the previous annotations. We can compute the Rand index using a function from the fossil package to assess the similarity between the two clustering results. A value of 1 would suggest the clustering results are identical, while a value of 0 would suggest that the results do not agree at all.\n\ng1 &lt;- as.numeric(colData(sfe)$cluster)\ng2 &lt;- as.numeric(colData(sfe)$celltype_mapped_refined)\n\nrand.index(g1, g2)\n#&gt; [1] 0.8464083\n\nThe relatively large Rand index suggests that cells are often found in the same cluster in both cases.\n\n\nUnivariate Spatial Statistics\nAt this point, we may be interested in identifying genes that exhibit spatial variability, or whose expression depends on spatial location within the tissue. Measures of spatial autocorrelation can be useful in identifyign genes that display spatial variablity. Among the most common measures are Moran’s I and Geary’s C. In the latter case, a less than 1 indicates positive spatial autocorrelation, while a value larger than 1 points to negative spatial autocorrelation. In the former case, positive and negative values of Moran’s I indicate positive and negative spatial autocorrelation, respectively.\nThese tests require a spatial neighborhood graph for computation of the statistic. There are several ways to define spatial neighbors and the findSpatialNeighbors() function wraps all of the methods implemented in the spdep package. Below, we compute a k-nearest neighborhood graph. The dist_type = \"idw\" weights the edges of the graph by the inverse distance between neighbors.\n\ncolGraph(sfe, \"knn5\") &lt;- findSpatialNeighbors(\n  sfe, method = \"knearneigh\", dist_type = \"idw\", \n  k = 5, style = \"W\")\n\nWe will also save the most variable genes for use in the computations below.\n\ndec &lt;- modelGeneVar(sfe)\nhvgs &lt;- getTopHVGs(dec, n = 100)\n\nWe use the runUnivariate() function to compute the spatial autocorrelation metrics and save the results and save them in the SFE object. The mc type for each test implements a permutation test for each statistic and relies on the nsim argument for computing a p-value for the statistic.\n\nsfe &lt;- runUnivariate(\n  sfe, type = \"geary.mc\", features = hvgs, \n  colGraphName = \"knn5\", nsim = 100, BPPARAM = MulticoreParam(2))\n\n\nsfe &lt;- runUnivariate(\n  sfe, type = \"moran.mc\", features = hvgs,\n  colGraphName = \"knn5\", nsim = 100, BPPARAM = MulticoreParam(2))\n\nsfe &lt;- colDataUnivariate(\n  sfe, type = \"moran.mc\", features = c(\"nCounts\", \"nGenes\"), \n  colGraphName = \"knn5\", nsim = 100)\n\nWe can plot the results of the Monte Carlo simulations:\n\nplotMoranMC(sfe, \"Meox1\")\n\n\n\n\n\n\n\n\nThe vertical line represents the observed value of Moran’s I and the density represents Moran’s I computed from the permuted data. These simulations suggest that the spatial autocorrelation for this feature is significant.\nThe function can also be used to plot the geary.mc results.\nNow, we might ask: which genes display the most spatial autocorrelation?\n\ntop_moran &lt;- rownames(sfe)[order(-rowData(sfe)$moran.mc_statistic_sample01)[1:4]]\n\nplotSpatialFeature(sfe, top_moran, colGeometryName = \"seg_coords\")\n\n\n\n\n\n\n\n\nIt appears that the genes with the highest spatial autocorrelation seem to have obvious expression patterns in the tissue.\nIt would be interesting to see if these genes are also differentially expressed in the clusters above. Non-spatial differential gene expression can be interrogated using the findMarkers() function implemented in the scran package and more complex methods for identifying spatially variable genes are actively being developed.\nThese analyses bring up interesting considerations. For one, it is unclear whether normalization scheme employed here effectively removes FOV batch effects. That said, there may be times where FOV differences are expected and represent biological differences, for example in the context of a tumor sample. It remains to be seen what normalization methods will perform best in these cases, and this is represents an area for research.\n\n\nSession Info\n\nsessionInfo()\n#&gt; R version 4.5.2 (2025-10-31)\n#&gt; Platform: aarch64-apple-darwin20\n#&gt; Running under: macOS Sequoia 15.6.1\n#&gt; \n#&gt; Matrix products: default\n#&gt; BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib \n#&gt; LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n#&gt; \n#&gt; locale:\n#&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#&gt; \n#&gt; time zone: America/Los_Angeles\n#&gt; tzcode source: internal\n#&gt; \n#&gt; attached base packages:\n#&gt; [1] stats4    stats     graphics  grDevices utils     datasets  methods  \n#&gt; [8] base     \n#&gt; \n#&gt; other attached packages:\n#&gt;  [1] BiocParallel_1.44.0             spdep_1.4-1                    \n#&gt;  [3] sf_1.0-21                       spData_2.3.4                   \n#&gt;  [5] patchwork_1.3.2                 fossil_0.4.0                   \n#&gt;  [7] shapefiles_0.7.2                foreign_0.8-90                 \n#&gt;  [9] maps_3.4.3                      sp_2.2-0                       \n#&gt; [11] dplyr_1.1.4                     tidyr_1.3.1                    \n#&gt; [13] purrr_1.2.0                     bluster_1.20.0                 \n#&gt; [15] scran_1.38.0                    scater_1.38.0                  \n#&gt; [17] ggplot2_4.0.0                   scuttle_1.20.0                 \n#&gt; [19] batchelor_1.26.0                SpatialExperiment_1.20.0       \n#&gt; [21] SingleCellExperiment_1.32.0     SummarizedExperiment_1.40.0    \n#&gt; [23] Biobase_2.70.0                  GenomicRanges_1.62.0           \n#&gt; [25] Seqinfo_1.0.0                   IRanges_2.44.0                 \n#&gt; [27] S4Vectors_0.48.0                BiocGenerics_0.56.0            \n#&gt; [29] generics_0.1.4                  MatrixGenerics_1.22.0          \n#&gt; [31] matrixStats_1.5.0               SFEData_1.12.0                 \n#&gt; [33] Voyager_1.12.0                  SpatialFeatureExperiment_1.12.1\n#&gt; \n#&gt; loaded via a namespace (and not attached):\n#&gt;   [1] splines_4.5.2             bitops_1.0-9             \n#&gt;   [3] filelock_1.0.3            tibble_3.3.0             \n#&gt;   [5] R.oo_1.27.1               lifecycle_1.0.4          \n#&gt;   [7] httr2_1.2.1               edgeR_4.8.0              \n#&gt;   [9] lattice_0.22-7            MASS_7.3-65              \n#&gt;  [11] magrittr_2.0.4            limma_3.66.0             \n#&gt;  [13] rmarkdown_2.30            yaml_2.3.10              \n#&gt;  [15] metapod_1.18.0            cowplot_1.2.0            \n#&gt;  [17] DBI_1.2.3                 RColorBrewer_1.1-3       \n#&gt;  [19] ResidualMatrix_1.20.0     multcomp_1.4-29          \n#&gt;  [21] abind_1.4-8               spatialreg_1.4-2         \n#&gt;  [23] R.utils_2.13.0            RCurl_1.98-1.17          \n#&gt;  [25] TH.data_1.1-4             rappdirs_0.3.3           \n#&gt;  [27] sandwich_3.1-1            ggrepel_0.9.6            \n#&gt;  [29] irlba_2.3.5.1             terra_1.8-80             \n#&gt;  [31] units_1.0-0               RSpectra_0.16-2          \n#&gt;  [33] dqrng_0.4.1               DelayedMatrixStats_1.32.0\n#&gt;  [35] codetools_0.2-20          DropletUtils_1.30.0      \n#&gt;  [37] DelayedArray_0.36.0       tidyselect_1.2.1         \n#&gt;  [39] memuse_4.2-3              farver_2.1.2             \n#&gt;  [41] ScaledMatrix_1.18.0       viridis_0.6.5            \n#&gt;  [43] BiocFileCache_3.0.0       jsonlite_2.0.0           \n#&gt;  [45] BiocNeighbors_2.4.0       e1071_1.7-16             \n#&gt;  [47] survival_3.8-3            tools_4.5.2              \n#&gt;  [49] ggnewscale_0.5.2          Rcpp_1.1.0               \n#&gt;  [51] glue_1.8.0                gridExtra_2.3            \n#&gt;  [53] SparseArray_1.10.1        xfun_0.54                \n#&gt;  [55] EBImage_4.52.0            HDF5Array_1.38.0         \n#&gt;  [57] withr_3.0.2               BiocManager_1.30.26      \n#&gt;  [59] fastmap_1.2.0             boot_1.3-32              \n#&gt;  [61] rhdf5filters_1.22.0       digest_0.6.37            \n#&gt;  [63] rsvd_1.0.5                R6_2.6.1                 \n#&gt;  [65] wk_0.9.4                  LearnBayes_2.15.1        \n#&gt;  [67] jpeg_0.1-11               RSQLite_2.4.3            \n#&gt;  [69] R.methodsS3_1.8.2         h5mread_1.2.0            \n#&gt;  [71] data.table_1.17.8         class_7.3-23             \n#&gt;  [73] httr_1.4.7                htmlwidgets_1.6.4        \n#&gt;  [75] S4Arrays_1.10.0           pkgconfig_2.0.3          \n#&gt;  [77] scico_1.5.0               gtable_0.3.6             \n#&gt;  [79] blob_1.2.4                S7_0.2.0                 \n#&gt;  [81] XVector_0.50.0            htmltools_0.5.8.1        \n#&gt;  [83] fftwtools_0.9-11          scales_1.4.0             \n#&gt;  [85] png_0.1-8                 knitr_1.50               \n#&gt;  [87] rjson_0.2.23              coda_0.19-4.1            \n#&gt;  [89] nlme_3.1-168              curl_7.0.0               \n#&gt;  [91] proxy_0.4-27              cachem_1.1.0             \n#&gt;  [93] zoo_1.8-14                rhdf5_2.54.0             \n#&gt;  [95] BiocVersion_3.22.0        KernSmooth_2.23-26       \n#&gt;  [97] parallel_4.5.2            vipor_0.4.7              \n#&gt;  [99] AnnotationDbi_1.72.0      s2_1.1.9                 \n#&gt; [101] pillar_1.11.1             grid_4.5.2               \n#&gt; [103] vctrs_0.6.5               BiocSingular_1.26.0      \n#&gt; [105] dbplyr_2.5.1              beachmat_2.26.0          \n#&gt; [107] sfheaders_0.4.4           cluster_2.1.8.1          \n#&gt; [109] beeswarm_0.4.0            evaluate_1.0.5           \n#&gt; [111] zeallot_0.2.0             magick_2.9.0             \n#&gt; [113] mvtnorm_1.3-3             cli_3.6.5                \n#&gt; [115] locfit_1.5-9.12           compiler_4.5.2           \n#&gt; [117] rlang_1.1.6               crayon_1.5.3             \n#&gt; [119] labeling_0.4.3            classInt_0.4-11          \n#&gt; [121] ggbeeswarm_0.7.2          viridisLite_0.4.2        \n#&gt; [123] deldir_2.0-4              Biostrings_2.78.0        \n#&gt; [125] tiff_0.1-12               Matrix_1.7-4             \n#&gt; [127] ExperimentHub_3.0.0       sparseMatrixStats_1.22.0 \n#&gt; [129] bit64_4.6.0-1             Rhdf5lib_1.32.0          \n#&gt; [131] KEGGREST_1.50.0           statmod_1.5.1            \n#&gt; [133] AnnotationHub_4.0.0       igraph_2.2.1             \n#&gt; [135] memoise_2.0.1             bit_4.6.0"
  },
  {
    "objectID": "seqspec_tutorials.html",
    "href": "seqspec_tutorials.html",
    "title": "Choose an Assay to Begin Your seqspec Tutorial",
    "section": "",
    "text": "10x Genomics Next GEM v3\n    \n    \n      \n      10x Genomics GEM X v4\n    \n  \n\n  \n  \n    \n      \n      Parse Evercode WT v2 (Single Index)\n    \n    \n      \n      Parse Evercode WT v2 (Dual Index)\n    \n    \n      \n      Parse Evercode WT v3"
  },
  {
    "objectID": "conda.html",
    "href": "conda.html",
    "title": "Creating a Conda Environment",
    "section": "",
    "text": "Conda is an open-source package and environment management system designed to make scientific computing workflows reproducible and portable. It allows you to:\n\nInstall and manage software (including Python and R packages) along with all their dependencies — even complex bioinformatics tools that are difficult to install manually.\nCreate isolated environments, so different projects can use different versions of the same software without conflicts.\nReproduce analyses easily, since an environment file (environment.yml) can capture the exact software versions used in your workflow.\n\nThis makes conda especially useful for computational biology and single-cell RNA-seq analysis, where multiple specialized tools (e.g., kb-python, scanpy, seqspec) must work together seamlessly.\n\n\n\n\n\n\nNoteInstalling Conda\n\n\n\nTo install conda, follow the instructions here. This page shows you how to install miniconda."
  },
  {
    "objectID": "conda.html#why-should-i-use-conda",
    "href": "conda.html#why-should-i-use-conda",
    "title": "Creating a Conda Environment",
    "section": "",
    "text": "Conda is an open-source package and environment management system designed to make scientific computing workflows reproducible and portable. It allows you to:\n\nInstall and manage software (including Python and R packages) along with all their dependencies — even complex bioinformatics tools that are difficult to install manually.\nCreate isolated environments, so different projects can use different versions of the same software without conflicts.\nReproduce analyses easily, since an environment file (environment.yml) can capture the exact software versions used in your workflow.\n\nThis makes conda especially useful for computational biology and single-cell RNA-seq analysis, where multiple specialized tools (e.g., kb-python, scanpy, seqspec) must work together seamlessly.\n\n\n\n\n\n\nNoteInstalling Conda\n\n\n\nTo install conda, follow the instructions here. This page shows you how to install miniconda."
  },
  {
    "objectID": "conda.html#create-a-new-environment",
    "href": "conda.html#create-a-new-environment",
    "title": "Creating a Conda Environment",
    "section": "Create a New Environment",
    "text": "Create a New Environment\nThere are many ways to organize your conda environments which depends on the uniqueness of your analysis workflows and the dependencies required. However you decide to use conda, you should have a dedicated conda environment for each project.\nTo create a conda environment (with Python), type into the command line:\nconda create --name myenv\nand replace myenv with your desired environment name. Then, to activate your environment, type:\nconda activate myenv\nNow, anything you run in this shell will use only the packages that you have explicitly installed. To deactivate your environment, type:\nconda deactivate\n\n\n\n\n\n\nNotePython or R?\n\n\n\nTo create your environment with a specific version of Python (e.g version 3.12), type into your command line:\nconda create --name myenv python=3.12\nIf you are instead analyzing your data with R, in this case with version 4.2, you can create your environment as follows:\nconda create --name myenv r-essentials r-base=4.2"
  },
  {
    "objectID": "conda.html#installing-a-package-with-conda",
    "href": "conda.html#installing-a-package-with-conda",
    "title": "Creating a Conda Environment",
    "section": "Installing a Package with Conda",
    "text": "Installing a Package with Conda\nTo install a package with conda, you usually have to specificy a conda channel. Conda channels are online repositories where packages are stored and distributed. When you install a package with conda, it looks for that package in one or more channels (for example, defaults, conda-forge, or bioconda).\n\nThe defaults channel is maintained by Anaconda and includes general-purpose packages.\nconda-forge is a community-maintained channel that provides up-to-date and cross-platform builds of thousands of scientific and technical packages.\nbioconda specializes in bioinformatics software and depends on conda-forge for many of its core libraries.\n\nWhen installing bioinformatics tools like kb-python or seqspec, it’s best practice to specify both conda-forge and bioconda as channels to ensure compatibility:\nconda install -c conda-forge -c bioconda kb-python"
  },
  {
    "objectID": "conda.html#recreate-an-old-environment",
    "href": "conda.html#recreate-an-old-environment",
    "title": "Creating a Conda Environment",
    "section": "Recreate an Old Environment",
    "text": "Recreate an Old Environment\nYou can save your conda environment in a YAML file with:\nconda env export --from-history &gt; environment.yml\nWith the environment.yml file, you can produce an identical copy of your conda environment with:\nconda env create -f environment.yml --name myenv"
  },
  {
    "objectID": "contact_us.html",
    "href": "contact_us.html",
    "title": "Contact Us",
    "section": "",
    "text": "Name \nEmail \nMessage\n\n\nSend Message"
  },
  {
    "objectID": "contact_us.html#still-have-questions-were-here-to-help",
    "href": "contact_us.html#still-have-questions-were-here-to-help",
    "title": "Contact Us",
    "section": "",
    "text": "Name \nEmail \nMessage\n\n\nSend Message"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "",
    "text": "Follow one of the following links to download a template seqspec according to the Parse WT kit that you used to generate your sequencing library:\n\nParse Evercode WT Mini\nParse Evercode WT\nParse Evercode WT Mega\n\nThen, follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the Parse Evercode WT v2 Dual-Indexed Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nIllumina i5 Index\nFixed\n8 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\ncDNA\nRandom\nVariable\n\n\nRound 1 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n22 bp\n\n\nRound 2 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n30 bp\n\n\nRound 3 Barcode\nOnList\n8 bp\n\n\nUMI\nRandom\n10 bp\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n10 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\nParse Biosciences recommends that the libary be sequenced in the following way:\n\n\n\n\n\n\n\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n66\npositive\ncDNA\n\n\nIndex 1\nTruseq Read 2\n8\npositive\nIllumina i7 Index\n\n\nIndex 2\nTruseq Read 1\n8\nnegative\nIllumina i5 Index\n\n\nRead 2\nTruseq Read 2\n86\nnegative\nUMI + Barcodes + Linkers"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library. For instance, if you used the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n!Assay\nseqspec_version: 0.3.0\nassay_id: Parse-Evercode-WT-v2-dual-index\nname: Dual-Indexed Parse Evercode WT v2\ndoi: https://support.parsebiosciences.com/hc/en-us/article_attachments/24507636161940\ndate: 2024-02-20\ndescription: Parse Evercode WT v2 using dual Illumina multiplex index\nmodalities: rna\nlib_struct: https://igvf.github.io/seqspec/\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Parse Evercode WT v2\nlibrary_kit: Parse Evercode WT v2 Dual Index"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\nParse recommends that you sequence Read 1 to at least 66 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 1 by changing the min_len and max_len to reflect the read length. For example, if you want to sequence 150 nucleotides, upate the read as follows:\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 150\n  max_len: 150\n  strand: pos\n  files:\n  - !File\n    ...\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filename&gt; # For Linux\n\nmd5 &lt;filename&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filename&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\nlibrary_spec:\n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXNNNNNNNNCCACAGTCTCAAGCACGTGGATNNNNNNNNAGTCGTACGCCGATGCGAAACATCGGCCACNNNNNNNNNNNNNNNNNNAGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 368\n  max_len: 368\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n  ...\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html",
    "href": "seqspec/webpages/10x/10x_v4.html",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "",
    "text": "To download a template seqspec, click here, and then follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/10x/10x_v4.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the 10X Chromium Single Cell 3’ Dual-Indexed v4 Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nIllumina i5 Index\nFixed\n10 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\nCell Barcode\nRandom\n16 bp\n\n\nUMI\nRandom\n12 bp\n\n\ncDNA\nRandom\nVariable\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n10 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\n10x Genomics recommends that the libary be sequenced in the following way:\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n28\npositive\nCell Barcode + UMI\n\n\nIndex 1\nTruseq Read 2\n10\npositive\nIllumina i7 Index\n\n\nIndex 2\nTruseq Read 1\n10\nnegative\nIllumina i5 Index\n\n\nRead 2\nTruseq Read 2\n90\nnegative\ncDNA"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/10x/10x_v4.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library. For instance, if you used the Chromium GEM-X Single Cell 3’ Kit v4, 16 rxns PN-1000691 reagent kit to construct your library and then the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n!Assay\nseqspec_version: 0.3.0\nassay_id: 10x-RNA-v4\nname: Dual Indexed 10x Genomics Chromium Single Cell 3' v4\ndoi: https://cdn.10xgenomics.com/image/upload/v1725314293/support-documents/CG000732_ChromiumGEM-X_SingleCell3_v4_CellSurfaceProtein_UserGuide_RevB.pdf\ndate: 2025-04-18\ndescription: 10x Genomics Chromium Single Cell 3' v4 using dual Illumina multiplex index\nmodalities: rna\nlib_struct: https://teichlab.github.io/scg_lib_structs/methods_html/10xChromium3.html\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Single-Cell RNA Sequencing Assay (OBI:0002631)\nlibrary_kit: Chromium GEM-X Single Cell 3' Kit v4, 16 rxns PN-1000691"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/10x/10x_v4.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\n10x Genomics recommends that you sequence Read 2 to at least 90 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 2 by changing the min_len and max_len to reflect the read length. For example, if you want to sequence 150 nucleotides, update the read as follows:\n- !Read\n  read_id: read_2\n  name: Read 2\n  modality: rna\n  primer_id: truseq_read2\n  min_len: 150\n  max_len: 150\n  strand: neg\n  files:\n  - !File\n    ...\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filename&gt; # For Linux\n\nmd5 &lt;filename&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filename&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/10x/10x_v4.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\nlibrary_spec: \n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTNNNNNNNNNNNNNNNNNNNNNNNNNNNNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 314\n  max_len: 314\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n    ...\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "seqfish.html",
    "href": "seqfish.html",
    "title": "seqFISH",
    "section": "",
    "text": "seqFISH is a powerful imaging-based single-cell transcriptomics technique that enables the spatial mapping of gene expression directly within tissue samples. Unlike droplet-based methods such as 10x Chromium or Parse Evercode, seqFISH preserves spatial context—allowing you to see not only which genes are active, but where they’re expressed within the cellular architecture.\n\n\n\nFigure: seqFish Mouse Embryo Map\n\n\nSee an example seqFISH analysis workflow here."
  },
  {
    "objectID": "R_packages.html",
    "href": "R_packages.html",
    "title": "Installing R Packages",
    "section": "",
    "text": "How you install R packages depends on whether you are using a conda environment. See our page on conda environments to learn how conda can help with version control and reproducibility. If you’re working within a conda environment, follow the conda installation instructions. Otherwise, you can install packages within your R script."
  },
  {
    "objectID": "R_packages.html#conda-installation",
    "href": "R_packages.html#conda-installation",
    "title": "Installing R Packages",
    "section": "Conda Installation",
    "text": "Conda Installation\n    conda install -c conda-forge r-&lt;package_name&gt;\nReplace &lt;package_name&gt; with the name of the package you wish to install."
  },
  {
    "objectID": "R_packages.html#r-installation",
    "href": "R_packages.html#r-installation",
    "title": "Installing R Packages",
    "section": "R Installation",
    "text": "R Installation\nIn R, you can install packages directly from within your script using the install.packages() function. For example, to install ggplot2, a popular package for data visualization, include the following line at the beginning of your script:\ninstall.packages(\"ggplot2\")"
  },
  {
    "objectID": "sample_pipeline.html",
    "href": "sample_pipeline.html",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "",
    "text": "This notebook demonstrates pre-processing and basic analysis of the 1k Human PBMCs dataset from 10x Genomics using the 10x Genomics Chromium Single Cell 3’ Next Gen v3.1 assay."
  },
  {
    "objectID": "sample_pipeline.html#an-introductory-analysis-pipeline",
    "href": "sample_pipeline.html#an-introductory-analysis-pipeline",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "An Introductory Analysis Pipeline",
    "text": "An Introductory Analysis Pipeline\nThere are many ways to perform a single-cell RNA sequencing (scRNA-seq) analysis and many aspects of your data to explore. In this tutorial, we outline a basic approach to quality control and analysis, along with some intuitive explanation of the underlying mathematics.\n\nThis scRNA-seq workflow has the following steps:\n\nRead Alignment\nQuality Control\nCell and Gene Filters\nNormalization and Variance Stabilization\nDimensionality Reduction\nClustering and Visualization\nDifferential Expression"
  },
  {
    "objectID": "sample_pipeline.html#initial-set-up",
    "href": "sample_pipeline.html#initial-set-up",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Initial Set-Up",
    "text": "Initial Set-Up\n\nInstall Python Packages\n\n# @title\n!pip install --quiet scanpy python-igraph louvain pybiomart\n!pip install --quiet matplotlib\n!pip install --quiet scikit-learn\n!pip install --quiet numpy\n!pip install --quiet scipy\n\n!pip install --quiet kb-python==0.29.1\n\n\n# @title\n# Import packages\nimport anndata\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib_inline.backend_inline import set_matplotlib_formats\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nfrom sklearn.decomposition import TruncatedSVD\nfrom scipy import sparse, io\n\nmatplotlib.rcParams.update({'font.size': 12})\nset_matplotlib_formats('retina')\n\n/usr/local/lib/python3.12/dist-packages/scanpy/_utils/__init__.py:33: FutureWarning: `__version__` is deprecated, use `importlib.metadata.version('anndata')` instead.\n  from anndata import __version__ as anndata_version\n/usr/local/lib/python3.12/dist-packages/scanpy/__init__.py:24: FutureWarning: `__version__` is deprecated, use `importlib.metadata.version('anndata')` instead.\n  if Version(anndata.__version__) &gt;= Version(\"0.11.0rc2\"):\n/usr/local/lib/python3.12/dist-packages/scanpy/readwrite.py:16: FutureWarning: `__version__` is deprecated, use `importlib.metadata.version('anndata')` instead.\n  if Version(anndata.__version__) &gt;= Version(\"0.11.0rc2\"):\n\n\n\n\nDownload the scRNA-seq data\n\n!wget -q https://cf.10xgenomics.com/samples/cell-exp/4.0.0/SC3_v3_NextGem_SI_PBMC_CSP_1K/SC3_v3_NextGem_SI_PBMC_CSP_1K_fastqs.tar\n!tar -xf SC3_v3_NextGem_SI_PBMC_CSP_1K_fastqs.tar"
  },
  {
    "objectID": "sample_pipeline.html#step-1-read-alignment",
    "href": "sample_pipeline.html#step-1-read-alignment",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 1: Read Alignment",
    "text": "Step 1: Read Alignment\n\nDownload a Pre-Built Index with kb ref\n\n!kb ref -d human -i index.idx -g t2g.txt\n\n[2025-10-21 04:48:16,146]    INFO [download] Skipping download because some files already exist. Use the --overwrite flag to overwrite.\n\n\n\n\nPseudoalign the scRNA-seq Data to the Index with kb count\n\n# This step runs `kb` to pseudoalign the reads, and then generate the cells x gene matrix in h5ad format.\n!kb count -i index.idx -g t2g.txt -x 10XV3 --h5ad -t 2 \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L002_R1_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L002_R2_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L003_R1_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L003_R2_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L004_R1_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L004_R2_001.fastq.gz\n\n[2025-10-21 04:48:27,652]    INFO [count] Skipping kallisto bus because output files already exist. Use the --overwrite flag to overwrite.\n[2025-10-21 04:48:27,652]    INFO [count] Sorting BUS file ./output.bus to ./tmp/output.s.bus\n[2025-10-21 04:48:46,541]    INFO [count] On-list not provided\n[2025-10-21 04:48:46,541]    INFO [count] Copying pre-packaged 10XV3 on-list to .\n[2025-10-21 04:48:47,999]    INFO [count] Inspecting BUS file ./tmp/output.s.bus\n[2025-10-21 04:49:06,258]    INFO [count] Correcting BUS records in ./tmp/output.s.bus to ./tmp/output.s.c.bus with on-list ./10x_version3_whitelist.txt\n[2025-10-21 04:49:31,255]    INFO [count] Sorting BUS file ./tmp/output.s.c.bus to ./output.unfiltered.bus\n[2025-10-21 04:49:38,691]    INFO [count] Generating count matrix ./counts_unfiltered/cells_x_genes from BUS file ./output.unfiltered.bus\n[2025-10-21 04:49:47,233]    INFO [count] Writing gene names to file ./counts_unfiltered/cells_x_genes.genes.names.txt\n[2025-10-21 04:49:47,817] WARNING [count] 13914 gene IDs do not have corresponding valid gene names. These genes will use their gene IDs instead.\n[2025-10-21 04:49:47,866]    INFO [count] Reading matrix ./counts_unfiltered/cells_x_genes.mtx\n[2025-10-21 04:49:48,887]    INFO [count] Writing matrix to h5ad ./counts_unfiltered/adata.h5ad\n\n\nWhen the --h5ad argument is used, kb count generates a H5AD-formatted Anndata matrix for downstream processing.\n\n\nLoad the Anndata Object\nFor this tutorial we will be using the Python package Scanpy.\nScanpy is a scalable Python library for analyzing single-cell RNA sequencing (scRNA-seq) data, built around an efficient AnnData object that stores expression matrices and associated metadata. It provides a comprehensive toolkit for preprocessing, visualization, clustering, and differential expression, enabling end-to-end analysis of large single-cell datasets.\nBelow we load the cells x genes matrix generated by kb-python as a H5AD-formatted object so that we can analyze our data with Scanpy.\n\n# import data\nadata = anndata.read_h5ad('counts_unfiltered/adata.h5ad')\nadata\n\nAnnData object with n_obs × n_vars = 281262 × 39546\n\n\n\n# Load the gene names and make them a column in the var dataframe\nwith open(\"counts_unfiltered/cells_x_genes.genes.names.txt\", 'r') as file:\n  adata.var['gene_names'] = file.readlines()"
  },
  {
    "objectID": "sample_pipeline.html#step-2-basic-quality-control",
    "href": "sample_pipeline.html#step-2-basic-quality-control",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 2: Basic Quality Control",
    "text": "Step 2: Basic Quality Control\n\nTest for Library Saturation\nBelow is a Gene vs. UMI plot, in which, for each cell, we visualize how many genes we detected. The purpose of this plot is to see if we have “saturated” our sequencing library and sampled a representative number of mRNA molecules for each cell. If this is the case, the curve should plateau as we sequence more UMIs.\n\n# Create a plot showing genes detected as a function of UMI counts.\nfig, ax = plt.subplots(figsize=(10, 7))\n\nx = np.asarray(adata.X.sum(axis=1))[:,0]\ny = np.asarray(np.sum(adata.X&gt;0, axis=1))[:,0]\n\nax.scatter(x, y, color=\"green\", alpha=0.25)\nax.set_xlabel(\"UMI Counts\")\nax.set_ylabel(\"Genes Detected\")\nax.set_xscale('log')\nax.set_yscale('log', nonpositive='clip')\n\nax.set_xlim((0.5, 4500))\nax.set_ylim((0.5,2000))\n\n\nplt.show()\n\n\n\n\n\n\n\n\nThe number of genes detected continues to increase with the number of UMI counts (x-axis) indicating that we have not saturated our library. More sequencing would likely yield more genes detected per cell.\n\n\nExamine the Knee Plot\nIn microfluidics-based scRNA-seq assays, such as the 10x Genomics Chromium platform, cells are encapsulated into droplets at low concentrations to minimize the formation of multiplets (droplets containing more than one cell). However, this approach also results in many droplets that contain no cells at all.\nDuring cell dissociation and droplet generation, some mRNA molecules are released into the surrounding solution — known as ambient RNA. When this ambient RNA is captured and sequenced, empty droplets may falsely appear to contain a cell.\nThe knee plot helps distinguish real cells from empty droplets based on total UMI counts per droplet. It was first introduced in the Drop-seq paper by Macosko et al., 2015.\nIn this plot, barcodes (droplets) are ranked by the number of associated UMI counts (shown on the x-axis), while the fraction of droplets with at least that many UMIs is shown on the y-axis. The “knee” of the curve represents the point where UMI counts drop sharply — separating droplets that likely contain real cells from those containing only ambient RNA.\n\n#@title Threshold Cells According to Knee Plot { run: \"auto\", vertical-output: true }\ncutoff = 400  #@param {type:\"integer\"}\nknee = np.sort((np.array(adata.X.sum(axis=1))).flatten())[::-1]\ncell_set = np.arange(len(knee))\nnum_cells = cell_set[knee &gt; cutoff][::-1][0]\n\nfig, ax = plt.subplots(figsize=(10, 7))\n\n\nax.loglog(knee, cell_set, linewidth=5, color=\"g\")\nax.axvline(x=cutoff, linewidth=3, color=\"k\")\n\n\nax.axhline(y=num_cells, linewidth=3, color=\"k\")\n\nax.set_xlabel(\"UMI Counts\")\nax.set_ylabel(\"Set of Barcodes\")\n\nplt.grid(True, which=\"both\")\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(f\"{num_cells:,.0f} cells passed the {cutoff} UMI threshold\")\n\n1,212 cells passed the 400 UMI threshold\n\n\nThe knee plot can be used to threshold cells based on the number of UMI counts they contain. In this example we use the number 3979 based on the publication describing the data."
  },
  {
    "objectID": "sample_pipeline.html#step-3-doublet-and-multiplet-removal",
    "href": "sample_pipeline.html#step-3-doublet-and-multiplet-removal",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 3: Doublet and Multiplet Removal",
    "text": "Step 3: Doublet and Multiplet Removal\n\nFilter empty droplets (According to the Knee Plot)\nIdeally, your data will contain no empty droplets that can be mistaken for real cells. We use our results from the knee plot here to filter them out.\n\n# Filter the cells according to the threshold determined from the knee plot\nsc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_cells(adata, min_counts=knee[num_cells])\n\n\n\n\n\n\n\nNote\n\n\n\nThe knee plot is a very simple method for getting rid of empty droplets. More sophisticated methods also exist. For instance, the methods EmptyDrops, CellBender, and DecontX use a statistical model to distinguish counts from ambient vs. cellular mRNA. This allows for both the identification and removal of empty droplets and the removal of technical noise from your count data.\n\n\n\n\nFilter Multiplets with Scrublet\nScrublet is an package designed to identify and remove multiplets (droplets containing more than one cell) from scRNA-seq data. It works by simulating artificial doublets through random pairwise combinations of real cells’ expression profiles. Scrublet then embeds both the simulated and observed cells in a low-dimensional space and flags real cells that lie close to simulated doublets as potential multiplets.\nScrublet operates on a raw count matrix, but requires that empty droplets be removed beforehand. If empty droplets remain in the dataset, they can distort the simulated doublet distribution and lead to inaccurate classifications. In addition, the Scrublet package should be applied to each sample/batch individually to avoid batch effects distorting the simulated doublet distribution.\nRemoving multiplets is an important quality-control step, as doublets can appear as hybrid cell types and obscure true biological variation during clustering and downstream analyses.\n\n\n\n\n\n\nNote\n\n\n\nThe Scrublet package is convenient because it is built-in to Scanpy, but it is not the only nor the most accurate doublet removal method. For a review of doublet detection methods, refer to the paper Benchmarking computational doublet-detection methods for single-cell RNA sequencing data by Nan Miles Chi and Jingyi Jessica Li.\n\n\n\nsc.pp.scrublet(adata, expected_doublet_rate=0.008)\n\n/usr/local/lib/python3.12/dist-packages/scanpy/neighbors/__init__.py:430: FutureWarning: Use obsm (e.g. `k in adata.obsm` or `adata.obsm.keys() | {'u'}`) instead of AnnData.obsm_keys, AnnData.obsm_keys is deprecated and will be removed in the future.\n  if \"X_diffmap\" in adata.obsm_keys():\n\n\nThe expected doublet rate depends upon your assay and the number of cells targeted. Refer to the documentation for you specific technology to get this number. We got the expected double rate 0.008 for 1,000 cells for 10x Chromium NextGem v3.1 here.\n\nadata = adata[adata.obs['predicted_doublet'] == False]\n\n\n\nFiltering Cells by Mitochondrial Content\nA healthy, intact cell should have no miRNA in the cytoplasm. As such, a high percentage of miRNA in the cytosol indicates cellular damage. We will identify the number of miRNA in each cell and remove cells with a certain percentage of miRNA.\n\nmito_ensembl_ids = sc.queries.mitochondrial_genes(\"hsapiens\", attrname=\"ensembl_gene_id\")\nmito_genes = set(mito_ensembl_ids[\"ensembl_gene_id\"].values)\n\nadata_base_var_names = adata.var_names.str.split('.').str[0]  # Removes minor version from var names\nmito_genes_base = {gene.split('.')[0] for gene in mito_genes}  # Removes minor version from mito_genes\n\n# Identify mitochondrial genes in adata.var using the stripped version of gene IDs\nadata.var['is_mito'] = adata_base_var_names.isin(mito_genes_base)\n\nmito_counts = adata[:, adata.var['is_mito']].X.sum(axis=1)\n\n# Calculate total counts per cell\ntotal_counts = adata.X.sum(axis=1)\n\n# Calculate percent mitochondrial gene expression per cell\nadata.obs['percent_mito'] = np.array(mito_counts / total_counts * 100).flatten()\n\nadata.obs['n_counts'] = adata.X.sum(axis=1).A1\n\n/tmp/ipython-input-2771333037.py:8: ImplicitModificationWarning: Trying to modify attribute `.var` of view, initializing view as actual.\n  adata.var['is_mito'] = adata_base_var_names.isin(mito_genes_base)\n\n\n\nsc.pl.scatter(adata, x='n_counts', y='percent_mito')\n\n/usr/local/lib/python3.12/dist-packages/scanpy/plotting/_anndata.py:397: FutureWarning: Use obs (e.g. `k in adata.obs` or `str(adata.obs.columns.tolist())`) instead of AnnData.obs_keys, AnnData.obs_keys is deprecated and will be removed in the future.\n  if key in adata.obs_keys():\n\n\n\n\n\n\n\n\n\nWe see above that the highest density of cells appear to have less than 30% miRNA content, so we will set our threshold to 30%\n\nadata = adata[adata.obs.percent_mito &lt; 30]\n\n\n\nFilter out genes that are not present in any cells\nIn general, we also want to get rid of genes with a low cell count to simplify our data.\n\nsc.pp.filter_genes(adata, min_cells=3)\n\n/usr/local/lib/python3.12/dist-packages/scanpy/preprocessing/_simple.py:293: ImplicitModificationWarning: Trying to modify attribute `.var` of view, initializing view as actual.\n  adata.var[\"n_cells\"] = number\n\n\n\n\nVisualizing count distributions\nExamination of the gene count and UMI count distributions is useful QC to evaluate the quality of the library and how deeply it was sequenced.\n\nsc.pl.violin(adata, ['n_genes', 'n_counts', 'percent_mito'], jitter=0.4, multi_panel=True)"
  },
  {
    "objectID": "sample_pipeline.html#step-4-normalization-and-variance-stabilization",
    "href": "sample_pipeline.html#step-4-normalization-and-variance-stabilization",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 4: Normalization and Variance Stabilization",
    "text": "Step 4: Normalization and Variance Stabilization\nIn an scRNA-seq experiment, UMI counts provide a relative estimate of transcript abundance within each cell. During library preparation and sequencing, mRNA molecules from different cells are reverse transcribed and sequenced to varying degrees. As a result, UMI counts cannot be interpreted as absolute measurements of RNA abundance.\nTo make counts comparable across cells, we normalize the data so that each cell has a total of 1×10⁶ counts. This scaling preserves integer values while allowing gene expression levels to be expressed as relative abundances within each cell.\nDownstream analyses such as PCA and differential expression typically assume that gene expression values are approximately continuous and have roughly constant variance across their range. However, raw scRNA-seq counts are overdispersed — they follow a negative binomial–like distribution, where the variance increases with the mean. To stabilize the variance and make the data more compatible with these methods, we apply a log transformation to the normalized counts.\n\n\n\n\n\n\nNote\n\n\n\nThis is a simplified approach for addressing overdispersion. Although log normalization is widely used, it does entirely produce constant-variance data. More sophisticated methods (e.g., variance-stabilizing transformations or model-based approaches) can better correct for overdispersion, but no perfect method currently exists — and those techniques are beyond the scope of this tutorial.\n\n\n\nsc.pp.normalize_total(adata, target_sum=1e6)\n\n\nsc.pp.log1p(adata)\n\n\nIdentify Highly Variable Genes\nTo simplify our data and reduce its dimensionality for downstream analyses, we limit our dataset to highly variable genes. Genes with low expression variance — such as housekeeping genes — contribute little to distinguishing between cell types or states, and can be excluded without loss of biological signal.\nHere, we retain only genes with a mean expression between 0.01 and 8 (values above 8 likely indicate technical artifacts) and a minimum normalized dispersion of 1. Cells are grouped (binned) by mean gene expression, and genes within each bin are filtered based on their normalized dispersion values.\n\n\n\n\n\n\nNote\n\n\n\nThe sc.pp.highly_variable_genes function in Scanpy expects input data that have already been normalized and variance-stabilized.\n\n\n\nsc.pp.highly_variable_genes(adata, min_mean=0.01, max_mean=8, min_disp=1, n_bins=20, flavor=\"seurat\")\nsc.pl.highly_variable_genes(adata)\n\n\n\n\n\n\n\n\nFinally, we scale the the data to unit variance and zero mean to standardize gene expression by preventing highly expressed genes from dominating downstream analysis and ensuring all genes are weighted equally.\n\nsc.pp.scale(adata, max_value=10)\n\n/usr/lib/python3.12/functools.py:912: UserWarning: zero-centering a sparse array/matrix densifies it.\n  return dispatch(args[0].__class__)(*args, **kw)"
  },
  {
    "objectID": "sample_pipeline.html#step-5-clustering-and-visualization",
    "href": "sample_pipeline.html#step-5-clustering-and-visualization",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 5: Clustering and Visualization",
    "text": "Step 5: Clustering and Visualization\nWhen analyzing scRNA-seq data, clustering is used to identify distinct cell types and states. Subsequently, differential expression analysis can reveal the genes that define these cellular states.\nThere are many algorithms for clustering cells, and while they have been compared in detail in various benchmarks (see e.g., Duo et al. 2018), there is no univerally agreed upon method. Here we demonstrate clustering using Louvain clustering, which is a popular method for clustering single-cell RNA-seq data.\n\n\n\n\n\n\nNote\n\n\n\nLouvain clustering is a non-deterministic algorithm, meaning it can produce slightly different results across runs. The number and size of clusters depend on a resolution parameter, which controls the granularity of the clustering. There is no universally optimal way to choose this parameter — it typically depends on how specific or fine-grained you want your cell populations to be.\n\n\n\nsc.pp.pca(adata, mask_var=\"highly_variable\")\n\n/usr/local/lib/python3.12/dist-packages/scanpy/preprocessing/_pca/__init__.py:245: FutureWarning: `__version__` is deprecated, use `importlib.metadata.version('anndata')` instead.\n  Version(ad.__version__) &lt; Version(\"0.9\")\n\n\n\n# Cluster the cells using Louvain clustering\nsc.pp.neighbors(adata, n_neighbors=30, n_pcs=10, knn=True)\nsc.tl.louvain(adata, resolution = 1.0)\n\n/usr/local/lib/python3.12/dist-packages/scanpy/neighbors/__init__.py:430: FutureWarning: Use obsm (e.g. `k in adata.obsm` or `adata.obsm.keys() | {'u'}`) instead of AnnData.obsm_keys, AnnData.obsm_keys is deprecated and will be removed in the future.\n  if \"X_diffmap\" in adata.obsm_keys():\n\n\nIt is useful to revisit the PCA projection with points colored by cluster. Previously we computed the PCA projection directly; here we use a function in Scanpy which does the same.\n\nVisualization with PCA\n\n# Perform PCA and plot the projection to the first two dimensions, with points colored according to the Louvain clusters.\nfig, ax = plt.subplots(figsize=(10, 7))\nsc.pl.pca(adata, color='louvain', ax=ax)\n\n\n\n\n\n\n\n\n\n\nNonlinear Visualization\nThe PCA representation results from a linear projection of the data from its original high-dimensional space to a lower-dimensional one (in this case, 2D). Such projections are valuable because they preserve global structure and are mathematically well-defined and reproducible.\nIn contrast, non-linear dimensionality reduction methods—the most popular being t-SNE and UMAP—can reveal complex, curved relationships in the data that linear methods cannot capture. However, they distort global distances and relationships, depend heavily on algorithmic parameters and random initialization, and may produce different results across runs. As a result, they are excellent for visualization but should be interpreted cautiously and not used for quantitative downstream analysis.\nTo read more, please see the Pachter Lab’s paper on the drawbacks of non-linear dimensionality reduction methods.\n\nt-SNE\n\n# Visualize cells with t-SNE. The n_pcs parameter sets the number of principal components to project to prior to\n# performing t-SNE\nsc.tl.tsne(adata, n_pcs=10)\nfig, ax = plt.subplots(figsize=(10, 7))\nsc.pl.tsne(adata, color='louvain', ax=ax)\n\n\n\n\n\n\n\n\n\n\nUMAP\n\n%%time\nsc.tl.umap(adata)\nfig, ax = plt.subplots(figsize=(10, 7))\nsc.pl.umap(adata, color='louvain', ax=ax)\n\n\n\n\n\n\n\n\nCPU times: user 3.07 s, sys: 7.18 ms, total: 3.08 s\nWall time: 2.97 s"
  },
  {
    "objectID": "sample_pipeline.html#step-6-differential-analysis",
    "href": "sample_pipeline.html#step-6-differential-analysis",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 6: Differential Analysis",
    "text": "Step 6: Differential Analysis\nFrom our clustering of cell states, we can perform differential expression analysis to identify marker genes that distinguish one cell state or cluster from another. This is typically done using simple statistical tests — such as the Wilcoxon rank-sum test or the t-test — which compare gene expression levels between clusters, or alternatively by fitting a more complex statistical model that accounts for variability across cells. By examining which genes are upregulated in each cluster, we can annotate clusters with known cell identities or infer novel cellular subpopulations.\nBelow, we use the Wilcoxon rank-sum test to identify marker genes. Because we are performing multiple hypothesis tests on the same dataset, we must adjust our p-values to control the false discovery rate. Several correction methods exist, but here we apply the Benjamini–Hochberg procedure, a widely used approach for multiple testing correction.\n\n\n\n\n\n\nNote\n\n\n\nStatistical tests such as the Wilcoxon rank-sum test and the t-test assume that the groups being compared were defined independently of the data. However, in single-cell analysis, clustering algorithms like Louvain define groups based on the data itself — by minimizing within-cluster variation and maximizing between-cluster separation. This violates the independence assumption, meaning these tests are not strictly valid. Despite this, they remain common in practice and can still provide useful exploratory insights when interpreted cautiously.\n\n\n\nsc.tl.rank_genes_groups(adata, gene_symbols='gene_names', groupby='louvain', method='wilcoxon')\n\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n\n\nThe below plot shows the 10 most highly expressed genes in each cluster (compared to the other clusters) according to the Wilcoxon z-score.\n\nsc.pl.rank_genes_groups(adata, n_genes=10, gene_symbols='gene_names', groupby='louvain', method='wilcoxon')"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to CBRC-SPEC Tutorials!",
    "section": "",
    "text": "This site is designed to guide Caltech students and staff through the full process of working with single-cell data—from formatting and processing to analysis—using the equipment and experimental setups commonly found at Caltech. Whether you’re just getting started or looking to refine your workflow, these tutorials provide step-by-step instructions tailored to our unique environment."
  },
  {
    "objectID": "index.html#explore-our-single-cell-workflows",
    "href": "index.html#explore-our-single-cell-workflows",
    "title": "Welcome to CBRC-SPEC Tutorials!",
    "section": "Explore Our Single Cell Workflows",
    "text": "Explore Our Single Cell Workflows\n\nClick a technology below to access step-by-step tutorials tailored to each single-cell assay.\n\n\nSingle-Cell RNA Sequencing Tutorials\n\n\n\n\n10x Genomics Chromium Single Cell 3’\n\n\n\n\n\n\n\nParse Biosciences Evercode WT\n\n\n\n\n\nSpatial Transcriptomics Tutorials\n\n\n\n\nseqFISH"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html",
    "href": "seqspec/webpages/10x/10x_v3.html",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "",
    "text": "To download a template seqspec, click here, and then follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/10x/10x_v3.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the 10X Chromium Single Cell 3’ Dual-Indexed v3 Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nIllumina i5 Index\nFixed\n10 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\nCell Barcode\nRandom\n16 bp\n\n\nUMI\nRandom\n12 bp\n\n\ncDNA\nRandom\nVariable\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n10 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\n10x Genomics recommends that the libary be sequenced in the following way:\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n28\npositive\nCell Barcode + UMI\n\n\nIndex 1\nTruseq Read 2\n10\npositive\nIllumina i7 Index\n\n\nIndex 2\nTruseq Read 1\n10\nnegative\nIllumina i5 Index\n\n\nRead 2\nTruseq Read 2\n90\nnegative\ncDNA"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/10x/10x_v3.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library and the library kit that you used. For instance, if you used the Chromium Next GEM Chip G Single Cell Kit, 48 rxns PN-1000120 reagent kit to construct your library and then the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n!Assay\nseqspec_version: 0.3.0\nassay_id: 10x-RNA-v3.1-dual-index\nname: Dual Indexed 10x Genomics Chromium Single Cell 3' v3.1 \ndoi: https://cdn.10xgenomics.com/image/upload/v1722285481/support-documents/CG000315_ChromiumNextGEMSingleCell3__GeneExpression_v3.1_DualIndex__RevF.pdf\ndate: 2024-07-29\ndescription: 10x Genomics Chromium Single Cell 3' v3.1 using dual Illumina multiplex index\nmodalities: rna\nlib_struct: https://teichlab.github.io/scg_lib_structs/methods_html/10xChromium3.html\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Single-Cell RNA Sequencing Assay (OBI:0002631)\nlibrary_kit: Chromium Next GEM Chip G Single Cell Kit, 48 rxns PN-1000120"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/10x/10x_v3.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\n10x Genomics recommends that you sequence Read 2 to at least 90 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 2 by changing the min_len and max_len to reflect the read length. For example, if you want to sequence 150 nucleotides, update the read as follows:\n- !Read\n  read_id: read_2\n  name: Read 2\n  modality: rna\n  primer_id: truseq_read2\n  min_len: 150\n  max_len: 150\n  strand: neg\n  files:\n  - !File\n    ...\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filename&gt; # For Linux\n\nmd5 &lt;filename&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filename&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/10x/10x_v3.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\nlibrary_spec: \n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTNNNNNNNNNNNNNNNNNNNNNNNNNNNNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 314\n  max_len: 314\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n    ...\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html",
    "href": "seqspec/webpages/Parse/parse_v2_single.html",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "",
    "text": "Follow one of the following links to download a template seqspec according to the Parse WT kit that you used to generate your sequencing library:\n\nParse Evercode WT Mini\nParse Evercode WT\nParse Evercode WT Mega\n\nThen, follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/Parse/parse_v2_single.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the Parse Evercode WT v2 Single-Indexed Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\ncDNA\nRandom\nVariable\n\n\nRound 1 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n22 bp\n\n\nRound 2 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n30 bp\n\n\nRound 3 Barcode\nOnList\n8 bp\n\n\nUMI\nRandom\n10 bp\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n6 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\nParse Biosciences recommends that the libary be sequenced in the following way:\n\n\n\n\n\n\n\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n74\npositive\ncDNA\n\n\nIndex 1\nTruseq Read 2\n6\npositive\nIllumina i7 Index\n\n\nRead 2\nTruseq Read 2\n86\nnegative\nUMI + Barcodes + Linkers"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/Parse/parse_v2_single.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library. For instance, if you used the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n\n!Assay\nseqspec_version: 0.3.0\nassay_id: Parse-Evercode-WT-v2-single-index\nname: Single-Indexed Parse Evercode WT v2\ndoi: https://support.parsebiosciences.com/hc/en-us/article_attachments/24507636161940\ndate: 2024-02-20\ndescription: Parse Evercode WT v2 using a single Illumina multiplex index\nmodalities: rna\nlib_struct: https://igvf.github.io/seqspec/\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Parse Evercode WT v2\nlibrary_kit: Parse Evercode WT v2 Single Index"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/Parse/parse_v2_single.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\nParse recommends that you sequence Read 1 to at least 66 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 1 by changing the min_len and max_len to reflect the read length. For example, if you want to sequence 150 nucleotides, upate the read as follows:\n\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 150\n  max_len: 150\n  strand: pos\n  files:\n  - !File\n    ...\n\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \n\nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filename&gt; # For Linux\n\nmd5 &lt;filename&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filename&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/Parse/parse_v2_single.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\n\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\n\nlibrary_spec:\n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXNNNNNNNNCCACAGTCTCAAGCACGTGGATNNNNNNNNAGTCGTACGCCGATGCGAAACATCGGCCACNNNNNNNNNNNNNNNNNNAGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 368\n  max_len: 368\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n  ...\n\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html",
    "href": "seqspec/webpages/Parse/parse_v3.html",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "",
    "text": "Follow one of the following links to download a template seqspec according to the Parse WT kit that you used to generate your sequencing library:\n\nParse Evercode WT Mini\nParse Evercode WT\nParse Evercode WT Mega\n\nThen, follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/Parse/parse_v3.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the Parse Evercode WT v3 Dual-Indexed Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nIllumina i5 Index\nFixed\n8 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\ncDNA\nRandom\nVariable\n\n\nRound 1 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n12 bp\n\n\nRound 2 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n12 bp\n\n\nRound 3 Barcode\nOnList\n8 bp\n\n\nUMI\nRandom\n10 bp\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n8 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\nParse Biosciences recommends that the libary be sequenced in the following way:\n\n\n\n\n\n\n\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n64\npositive\ncDNA\n\n\nIndex 1\nTruseq Read 2\n8\npositive\nIllumina i7 Index\n\n\nIndex 2\nTruseq Read 1\n8\nnegative\nIllumina i5 Index\n\n\nRead 2\nTruseq Read 2\n58\nnegative\nUMI + Barcodes + Linkers"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/Parse/parse_v3.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library. For instance, if you used the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n!Assay\nseqspec_version: 0.3.0\nassay_id: Parse-Evercode-WT-v3\nname: Dual-Indexed Parse Evercode WT v3\ndoi: https://support.parsebiosciences.com/hc/en-us/article_attachments/31841872776724\ndate: 2024-02-20\ndescription: Parse Evercode WT v3 using dual Illumina multiplex index\nmodalities: rna\nlib_struct: ##TBD##\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Parse Evercode WT v3\nlibrary_kit: Parse Evercode WT v3"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/Parse/parse_v3.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\nParse recommends that you sequence Read 1 to at least 64 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 1 by changing the ‘min_len’ and ‘max_len’ to reflect the read length. For example, if you want to sequence 150 nucleotides, upate the read as follows:\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 150\n  max_len: 150\n  strand: pos\n  files:\n  - !File\n    ...\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filepath&gt; # For Linux\n\nmd5 &lt;filepath&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filepath&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/Parse/parse_v3.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\nlibrary_spec:\n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXNNNNNNNNGAGGTGGTTGGANNNNNNNNCTGACCCCTCATNNNNNNNNNNNNNNNNNNAGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 342\n  max_len: 342\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n  ...\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "python_packages.html",
    "href": "python_packages.html",
    "title": "Installing Python Packages",
    "section": "",
    "text": "How you install Python packages depends on whether you are using a conda environment. See our page on conda environments to learn how conda can help with version control and reproducibility. If you’re working within a conda environment, follow the conda installation instructions. Otherwise, you can install packages using pip."
  },
  {
    "objectID": "python_packages.html#kb-python",
    "href": "python_packages.html#kb-python",
    "title": "Installing Python Packages",
    "section": "kb-python",
    "text": "kb-python\n\nConda\nconda install -c conda-forge -c bioconda kb-python\n\n\npip\npip install kb-python"
  },
  {
    "objectID": "python_packages.html#seqspec",
    "href": "python_packages.html#seqspec",
    "title": "Installing Python Packages",
    "section": "seqspec",
    "text": "seqspec\n\nConda\nconda install -c conda-forge -c bioconda seqspec\n\n\npip\npip install kb-python"
  },
  {
    "objectID": "parse.html",
    "href": "parse.html",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "",
    "text": "To ensure that all data generated at Caltech are standardized and reproducible, we require that every dataset include a seqspec file. A seqspec file provides a machine-readable description of your experiment, specifying the assay information, library structure, and read structure in a YAML-formatted file."
  },
  {
    "objectID": "parse.html#step-0-get-started-with-seqspec",
    "href": "parse.html#step-0-get-started-with-seqspec",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "",
    "text": "To ensure that all data generated at Caltech are standardized and reproducible, we require that every dataset include a seqspec file. A seqspec file provides a machine-readable description of your experiment, specifying the assay information, library structure, and read structure in a YAML-formatted file."
  },
  {
    "objectID": "parse.html#step-1-align-your-library-reads-with-kb-python",
    "href": "parse.html#step-1-align-your-library-reads-with-kb-python",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "Step 1: Align Your Library Reads with kb-python",
    "text": "Step 1: Align Your Library Reads with kb-python\nAligning reads from a Parse Evercode WT library requires additional consideration compared to other scRNA-seq assays. Unlike most platforms, which use primers targeting a specific region of each mRNA molecule, Parse Evercode WT employs two types of primers — poly(T) primers that bind to the 3′ poly(A) tail and random oligo primers that bind to random internal regions of the transcript. Each primer type has its own corresponding set of cell-specific barcodes. As a result, each cell is represented by two barcodes rather than one, as in assays such as 10x Genomics.\nTo generate a unified count matrix from the raw reads, the counts associated with these two barcodes must be collapsed so that each cell is represented once. In kb-python, this is accomplished by replacing all random oligo barcodes with their corresponding poly(T) barcodes using the -r argument.\n\n\n\n\n\n\nImportant\n\n\n\nWhen using -r to specify a replacement list in kb count, two count matrices will be produced: one with the original barcodes (stored in the output file counts_unfiltered) and one with the replacement barcodes (stored in the output file counts_unfiltered_modified)."
  },
  {
    "objectID": "parse.html#an-example-v2",
    "href": "parse.html#an-example-v2",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "An Example (v2)",
    "text": "An Example (v2)\nHere we provide a brief example of how to align a Parse Evercode WT v2 library to a reference using kb count. For a more in-depth tutorial, see our page on kb-python.\nTo psuedoalign your Parse data, run:\nkb count --h5ad -x SPLIT-SEQ -r v2_replace.txt \\\n  -g t2g.txt -i index.idx R1.fastq.gz R2.fastq.gz\nwhere index.idx and t2g.txt are files generated by kb-ref, and R1.fastq.gz and R2.fastq.gz are your raw paired-end reads. The replace.txt file specifies the barcode substitution. The --h5ad argument generates an h5ad formatted file for downstream processing with Scanpy.\nIf you performed a single-nucleus RNA-seq experiment, instead use the NAC workflow to align both nascent and mature reads:\nkb count --h5ad -r v2_replace.txt --workflow=nac -x 10XV3 -g t2g.txt -i index.idx \\\n  -c1 cdna.txt -c2 nascent.txt R1.fastq.gz R2.fastq.gz\nHere, cdna.txt and nascent.text are files generated by kb ref -workflow=nac.\nYou can download the file v2_replace.txt for the v2 chemistry here."
  },
  {
    "objectID": "parse.html#an-example-v3",
    "href": "parse.html#an-example-v3",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "An Example (v3)",
    "text": "An Example (v3)\nCurrently, kb-python does not include a built-in specification for Parse Evercode WT v3. Instead, we must provide the assay information manually by specifying:\n\nv3_onlist.txt — a list of valid cell barcodes\na technology string defining barcode positions within the read: -x \"1,10,18,1,30,38,1,50,58:1,0,10:0,0,0\"\nv3_replace.txt - mapping between poly(T) and random oligo barcodes\nthe orientation of the first read (R1) with relative to your library specification: --strand=forward\nthe read parity (whether the assay produces single- or paired-end reads): --paired=paired\n\nThen, run:\nkb count --h5ad --strand=forward --parity=paired \\\n  -r v3_replace.txt -w v3_onlist.txt \\\n  -x \"1,10,18,1,30,38,1,50,58:1,0,10:0,0,0 \\\n  -g t2g.txt -i index.idx R1.fastq.gz R2.fastq.gz"
  },
  {
    "objectID": "parse.html#step-2-process-and-analyze-your-data",
    "href": "parse.html#step-2-process-and-analyze-your-data",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "Step 2: Process and Analyze Your Data",
    "text": "Step 2: Process and Analyze Your Data\nNow you are ready to process your data! To continue with downstream analysis follow our example scRNA-seq pipeline."
  },
  {
    "objectID": "kb_python.html",
    "href": "kb_python.html",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "",
    "text": "Note\n\n\n\nThis tutorial provides a brief introduction to kb-python. For a more in-depth guide, see the official documentation.\nkb-python is a lightweight, command-line toolkit for processing single-cell RNA sequencing (scRNA-seq) data. It provides an efficient and transparent way to convert raw sequencing reads into gene count matrices ready for downstream analysis.\nThe tool integrates two powerful components:\nTogether, these tools enable a streamlined and modular workflow that supports flexible experimental designs and efficient large-scale processing.\nA typical kb-python workflow includes:"
  },
  {
    "objectID": "kb_python.html#workflows",
    "href": "kb_python.html#workflows",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "Workflows",
    "text": "Workflows\nkb-python provides three workflows tailored to different experimental setups and analysis goals. The two most commonly used are:\n\nNAC workflow – quantifies nascent (unspliced) transcripts. This workflow is typically used for single-nucleus RNA-seq experiments, where a substantial portion of captured mRNA remains unspliced.\nStandard workflow – quantifies mature (fully spliced) transcripts. This workflow is suitable when you are interested only in processed mRNA."
  },
  {
    "objectID": "kb_python.html#step-1-generate-a-reference-index",
    "href": "kb_python.html#step-1-generate-a-reference-index",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "Step 1: Generate a Reference Index",
    "text": "Step 1: Generate a Reference Index\nThe first step of any RNA-seq analysis is aligning your reads to a reference genome. To do this, kb-python requires a reference index representing the set of target transcripts to which your reads will be mapped.\nkb-python conveniently has a precompiled set of indices for the following species:\n\nhuman\nmouse\ndog\nmonkey\nzebrafish\n\n\n\n\n\n\n\nNoteWhat if kb-python doesn’t have the index I need?\n\n\n\nIf you require a custom index, please refer to Generate a reference index in the documentation.\n\n\nFor the standard workflow, you can load the human index as follows:\nkb ref -d human -i index.idx -g t2g.txt\nwhich will create the files index.idx and t2g.txt.\nand for the nascent workflow,\nkb ref --workflow=nac -d human -i index.idx \\ \n    -g t2g.txt -c1 cdna.txt -c2 nascent.txt\nwhich will additionally generate the files cdna.txt and nascent.txt.\n\n\n\n\n\n\nNote\n\n\n\nSee how the precompiled indices were generated here"
  },
  {
    "objectID": "kb_python.html#step-2-align-to-reference-genome",
    "href": "kb_python.html#step-2-align-to-reference-genome",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "Step 2: Align to Reference Genome",
    "text": "Step 2: Align to Reference Genome\nThe next step is to generate a count matrix by pseudoaligning the reads to your reference index using the kb count command. For example, suppose you have two paired-end FASTQ files (read1.fastq and read2.fastq) from a 10x Chromium NextGen v3 library.\nFor the standard workflow, you can perform pseudoalignment with:\nkb count -i index_file.idx -g t2g_file.txt -x 10XV3 \\\n    -o output_dir read1.fastq read2.fastq\nand for the nascent workflow,\nkb count --workflow=nac -i index_file.idx -g t2g_file.txt -c1 cdna.txt \\\n    -c2 nascent.txt -x 10XV3 -o output_dir read1.fastq read2.fastq\nwhere output_dir is the folder where you wish the results of kb_count to be stored.\n\n\n\n\n\n\nNoteWhat is a FASTQ file?\n\n\n\nFASTQ files are the standard format for storing raw sequencing reads from next-generation sequencing instruments. Each read in a FASTQ file is represented by four lines:\n@SEQ_ID\nGATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT\n+\n!''*((((***+))%%%++)(%%%%).1***-+*''))**55CCF&gt;&gt;&gt;&gt;&gt;&gt;CCCCCCC65\n\nLine 1 – Read identifier (begins with @)\nLine 2 – Nucleotide sequence\nLine 3 – Separator line (usually just +)\nLine 4 – Quality scores for each base (encoded as ASCII characters)\n\nkb count accepts both raw and gzipped FASTQ files. If your reads are stored in another file format, you will have to convert to FASTQ before pseudoalignment with kb-python.\n\n\nChange -x 10XV3 according to the specific technology you used to generate your library.\n\n10X Chromium GEM-X V4: -x 10XV4\nParse Evercode WT v2: -x SPLITSEQ\n\nTo see a complete list of technologies and their corresponding technology strings, type kb --list into your terminal.\n\nParse Evercode WT v3: Using a Custom Specification\nCurrently, kb-python does not include a built-in specification for the Parse Evercode WT v3 chemistry. To align Parse v3 data, you must manually specify the assay configuration by providing:\n\nv3_onlist.txt — a list of valid cell barcodes\na technology string defining barcode positions within the read: -x \"1,10,18,1,30,38,1,50,58:1,0,10:0,0,0\"\nthe orientation of the first read (R1) with relative to your library specification: --strand=forward\nthe read parity (whether the assay produces single- or paired-end reads): --paired=paired\n\nThen, run:\nkb count --h5ad --strand=forward --parity=paired \\\n  -w v3_onlist.txt -x \"1,10,18,1,30,38,1,50,58:1,0,10:0,0,0 \\\n  -g t2g.txt -i index.idx R1.fastq.gz R2.fastq.gz\n\n\nParse Evercode WT: Substituting Barcodes with the -r Argument\nThe Parse Evercode WT chemistry is unique in that each cell has two cell-specific barcodes rather than one. Since kb-python expects a single barcode per cell, you must collapse barcode pairs before pseudoalignment. This is done using the -r argument in kb count, for example:\nkb count -r &lt;replace_file&gt; ...\nwhere &lt;replace_file&gt; is a TSV file with two columns:\n\nColumn 1: barcodes to be replaced\nColumn 2: corresponding replacement barcodes\n\nYou can download:\n\nv2_replace.txt for v2 chemistry here\nv3_replace.txt for v3 chemistry here\n\n\n\n\n\n\n\nImportant\n\n\n\nWhen using -r to specify a replacement list in kb count, two count matrices will be produced: one with the original barcodes (stored in the output file counts_unfiltered) and one with the replacement barcodes (stored in the output file counts_unfiltered_modified)."
  },
  {
    "objectID": "kb_python.html#next-steps",
    "href": "kb_python.html#next-steps",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "Next Steps",
    "text": "Next Steps\nAfter generating your count matrix, you can import it into analysis tools such as Scanpy, Seurat, or Bioconductor for downstream processing, clustering, and visualization."
  },
  {
    "objectID": "10x.html",
    "href": "10x.html",
    "title": "Analyzing Your 10x Chromium Single Cell 3’ scRNA-seq Assay Data",
    "section": "",
    "text": "To ensure that all data generated at Caltech are standardized and reproducible, we require that every dataset include a seqspec file. A seqspec file provides a machine-readable description of your experiment, specifying the assay information, library structure, and read structure in a YAML-formatted file."
  },
  {
    "objectID": "10x.html#step-0-get-started-with-seqspec",
    "href": "10x.html#step-0-get-started-with-seqspec",
    "title": "Analyzing Your 10x Chromium Single Cell 3’ scRNA-seq Assay Data",
    "section": "",
    "text": "To ensure that all data generated at Caltech are standardized and reproducible, we require that every dataset include a seqspec file. A seqspec file provides a machine-readable description of your experiment, specifying the assay information, library structure, and read structure in a YAML-formatted file."
  },
  {
    "objectID": "10x.html#step-1-align-your-library-reads-with-kb-python",
    "href": "10x.html#step-1-align-your-library-reads-with-kb-python",
    "title": "Analyzing Your 10x Chromium Single Cell 3’ scRNA-seq Assay Data",
    "section": "Step 1: Align Your Library Reads with kb-python",
    "text": "Step 1: Align Your Library Reads with kb-python\nAligning reads from a 10x Genomics Library is relatively straightforward. After generating a reference index with kb ref, align your reads to the reference with kb count.\n\nAn Example\nHere we provide a brief example of how to align a 10x library to a reference using kb count. For a more in-depth tutorial, see our page on kb-python.\nTo psuedoalign your scRNA-seq 10x data, run:\nkb count --h5ad -x 10XV3 -g t2g.txt -i index.idx \\\n  R1.fastq.gz R2.fastq.gz\nwhere index.idx and t2g.txt are files generated by kb ref, and R1.fastq.gz and R2.fastq.gz are your raw paired-end reads. The --h5ad argument outputs an .h5ad file suitable for downstream processing with Scanpy.\nIf you performed a single-nucleus RNA-seq experiment, instead use the NAC workflow to align both nascent and mature reads:\nkb count --h5ad -x 10XV3 --workflow=nac -g t2g.txt -i index.idx  \\ \n  -c1 cdna.txt -c2 nascent.txt R1.fastq.gz R2.fastq.gz\nHere, cdna.txt and nascent.text are files generated by kb ref --workflow=nac.\n\n\n\n\n\n\nImportant\n\n\n\nThis example is specifically for the 10x Chromium Single Cell Next Gem v3 chemistry for the v4 chemistry, replace the technology string -x 10XV3 with -x 10XV4."
  },
  {
    "objectID": "10x.html#step-2-process-and-analyze-your-data",
    "href": "10x.html#step-2-process-and-analyze-your-data",
    "title": "Analyzing Your 10x Chromium Single Cell 3’ scRNA-seq Assay Data",
    "section": "Step 2: Process and Analyze Your Data",
    "text": "Step 2: Process and Analyze Your Data\nNow you are ready to process your data! To continue with downstream analysis follow our example scRNA-seq pipeline."
  }
]