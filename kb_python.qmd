---
title: "Pseudoalignment of scRNA-seq Reads with `kb-python`"
---
::: {.callout-note}
This tutorial provides a brief introduction to kb-python.
For a more in-depth guide, see the [official documentation](https://kallisto.readthedocs.io/en/latest/index.html) and reference the papers for [kb-python](https://www.nature.com/articles/s41596-024-01057-0), [bustools](http://academic.oup.com/bioinformatics/article/35/21/4472/5487510?login=true), and [kallisto](https://www.nature.com/articles/nbt.3519).
:::

**kb-python** is a lightweight, command-line toolkit for processing single-cell RNA sequencing (scRNA-seq) data. It provides an efficient and transparent way to convert raw sequencing reads into gene count matrices ready for downstream analysis.

The tool integrates two powerful components:

* **kallisto** - performs fast and accurate transcript quantification using pseudoalignment

* **bustools** - manages barcode and UMI information in the BUS (Barcode, UMI, Set) file format.

Together, these tools enable a streamlined and modular workflow that supports flexible experimental designs and efficient large-scale processing.

A typical kb-python workflow includes:

* Building a reference index with `kb ref`

* Processing **FASTQ** files into the **BUS format** with `kb count`

* Generating a count matrix summarizing gene expression per cell

:::{.callout-note title="Install seqspec"}
In order to install seqspec, follow our installation instructions [here](python_packages.qmd#kb-python).
:::

## Workflows

kb-python provides three workflows tailored to different experimental setups and analysis goals. The two most commonly used are:

* **NAC workflow** – quantifies nascent (unspliced) transcripts. This workflow is typically used for **single-nucleus RNA-seq** experiments, where a substantial portion of captured mRNA remains unspliced.

* **Standard workflow** – quantifies mature (fully spliced) transcripts. This workflow is suitable when you are interested only in processed mRNA.

## Step 1: Generate a Reference Index
The first step of any RNA-seq analysis is aligning your reads to a reference genome. To do this, kb-python requires a reference index representing the set of target transcripts to which your reads will be mapped.

### Using a Default Index
kb-python conveniently has a precompiled set of indices for the following species:

* human
* mouse
* dog 
* monkey
* zebrafish

For the **standard workflow**, you can load the human index as follows:

```bash
kb ref -d human -i index.idx -g t2g.txt
```

which will create the files index.idx and t2g.txt.

and for the **nascent workflow**,

```bash
kb ref --workflow=nac -d human -i index.idx \ 
    -g t2g.txt -c1 cdna.txt -c2 nascent.txt
```

which will additionally generate the files cdna.txt and nascent.txt.

::: {.callout-note}
See how the precompiled indices were generated [here](https://github.com/pachterlab/kallisto-transcriptome-indices).
:::

### Generating a Custom Index
In order to make a custom index, you must specify a **genome FASTA reference file** and a **GTF annotation file** from which to extract the transcript sequences. You can obtain these files from [**ENSEMBL**](https://useast.ensembl.org/index.html). We recommend using the **primary assembly FASTA file** (ends `.dna.primary_assembly.fa.gz`).

Then, to generate an index for the **standard workflow**, run:
```bash
kb ref  -i index.idx -g t2g.txt -f1 cdna.fasta genome.fasta genome.gtf
```

and for the **nac workflow**, run:
```bash
kb ref --workflow=nac -i index.idx -g t2g.txt -c1 cdna.txt -c2 nascent.txt \
    -f1 cdna.fasta -f2 nascent.fasta genome.fasta genome.gtf
```

## Step 2: Align to Reference Genome
The next step is to generate a count matrix by pseudoaligning the reads to your reference index using the `kb count` command. For example, suppose you have two paired-end FASTQ files (read1.fastq and read2.fastq) from a 10x Chromium NextGen v3 library.

For the **standard workflow**, you can perform pseudoalignment with:

```bash
kb count -i index_file.idx -g t2g_file.txt -x 10XV3 \
    -o output_dir read1.fastq read2.fastq
```

and for the **nascent workflow**,

```bash
kb count --workflow=nac -i index_file.idx -g t2g_file.txt -c1 cdna.txt \
    -c2 nascent.txt -x 10XV3 -o output_dir read1.fastq read2.fastq
```

where `output_dir` is the folder where you wish the results of `kb_count` to be stored.

::: {.callout-note title="What is a FASTQ file?"}
FASTQ files are the standard format for storing raw sequencing reads from next-generation sequencing instruments. Each read in a FASTQ file is represented by four lines:

```ruby
@SEQ_ID
GATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT
+
!''*((((***+))%%%++)(%%%%).1***-+*''))**55CCF>>>>>>CCCCCCC65
```

* **Line 1** – Read identifier (begins with @)

* **Line 2** – Nucleotide sequence

* **Line 3** – Separator line (usually just +)

* **Line 4** – Quality scores for each base (encoded as ASCII characters)

`kb count` accepts both raw and gzipped FASTQ files. If your reads are stored in another file format, you will have to convert to FASTQ before pseudoalignment with kb-python.
:::

Change `-x 10XV3` according to the specific technology you used to generate your library.

* 10X Chromium GEM-X V4: `-x 10XV4`
* Parse Evercode WT v2: `-x SPLITSEQ`

To see a complete list of technologies and their corresponding technology strings, type `kb --list` into your terminal.

### Batch Pseudoaligment
In most scRNA-seq experiments, you will have multiple samples, each with its own pair of FASTQ files. Instead of running `kb count` separately on every sample, kb-python allows you to process many samples in a single command using the`--batch-barcodes` flag.

To perform a batch pseudoalignment, run:
```bash
kb count ... --batch-barcodes batch.txt
```
filling in the command with the parameters specific to your experiment. The batch.txt file must be a **space-separated** file, with one row per sample. Each row should contain:

```txt
sample_name read1.fastq.gz read2.fastq.gz
```

— that is, the name of the sample followed by the paths to its Read 1 and Read 2 FASTQ files. 

kb-python will automatically process each sample independently and prepend a **unique, artificially generated sample-specific barcode** to the beginning of every cell barcode. This ensures that cell barcodes from different samples remain distinguishable in the combined output without altering the underlying cellular barcodes themselves.

A list of these sample-specific barcode prefixes is saved in `counts_unfiltered/cells_x_genes.barcodes.prefix.txt`, which maps each cell barcode to its corresponding sample barcode.

### Parse Evercode WT v3: Using a Custom Specification

Currently, **kb-python** does not include a built-in specification for the **Parse Evercode WT v3** chemistry. To pseudoalign Parse v3 data, you must manually specify the assay configuration by providing:

* <a href="v3_onlist.txt" download>v3_onlist.txt</a> — a list of valid cell barcodes

* a technology string defining barcode positions within the read: `-x "1,10,18,1,30,38,1,50,58:1,0,10:0,0,0"`

* the orientation of the first read (R1) with relative to your library specification: `--strand=forward`

* the read parity (whether the assay produces single- or paired-end reads): `--paired=paired`

Then, run:
```bash
kb count --h5ad --strand=forward --parity=paired \
  -w v3_onlist.txt -x "1,10,18,1,30,38,1,50,58:1,0,10:0,0,0 \
  -g t2g.txt -i index.idx R1.fastq.gz R2.fastq.gz
```

### Parse Evercode WT: Substituting Barcodes with the `-r` Argument
The Parse Evercode WT chemistry is unique in that each cell has two cell-specific barcodes rather than one. Since kb-python expects a single barcode per cell, you must collapse barcode pairs before pseudoalignment.
This is done using the `-r` argument in kb count, for example:

```bash
kb count -r <replace_file> ...
```

where \<replace_file\> is a **TSV** file with two columns:

* Column 1: barcodes to be replaced

* Column 2: corresponding replacement barcodes

You can download:

* v2_replace.txt for v2 chemistry <a href="v2_replace.txt" download>here</a>

* v3_replace.txt for v3 chemistry <a href="v3_replace.txt" download>here</a>

:::{.callout-important}
When using `-r` to specify a replacement list in kb count, two count matrices will be produced: one with the original barcodes (stored in the output file `counts_unfiltered`) and one with the replacement barcodes (stored in the output file `counts_unfiltered_modified`).
:::

### Validating Pseudoalignment with the `run_info.json` file
When you run kallisto through kb-python, it generates a file called run_info.json. This file summarizes essential metrics from the pseudoalignment step and helps you verify that your reads were successfully mapped to the reference transcriptome. Although it is a small file, it contains several important fields that give a quick indication of alignment quality and potential issues with your input data, reference files, or library chemistry.

#### Key Metrics to Evaluate

1. `n_processed`

    This value reports the total number of reads (or read pairs) that kallisto attempted to pseudoalign. It should match your expectation based on the number of reads in your FASTQ files. A much smaller number than expected usually indicates truncated FASTQ files, incorrect file paths, corrupted input, or an early pipeline failure.

2. `p_pseudoaligned`
    
    This is the fraction of reads that successfully pseudoaligned (`n_pseudoaligned` / `n_processed`). It is the most important single metric.
    Typical expectations:
    * Bulk RNA-seq: often >80–90%
    * scRNA-seq (10x): usually 60–90%
    * Multiome or non-standard assays: more variable

    Very low values (e.g., <30%) almost always indicate a mismatch between your reference and your reads rather than a biological.

3. `p_unique`

    This value reports the fraction of reads that pseudoaligned uniquely to a single transcript rather than mapping to multiple possible targets. For most scRNA-seq datasets, a value above 20% is expected, though this depends heavily on the organism, assay, and read length; in some cases, values as low as 10% can still be normal.

    A low `p_unique` can occur when:

    * many transcripts share highly similar sequences (e.g., paralogs, pseudogenes),
    * the reference is incomplete or poorly annotated,
    * reads are too short or low-quality,
    * adapters or barcodes were not properly trimmed,
    * a high percentage of the reads originate from ribosomal RNA.

    While `p_pseudoaligned` tells you how many reads mapped at all, `p_unique` tells you how confidently kallisto could assign those reads.

4. `Runtime information`

    Fields like `start_time`, `end_time`, and sometimes call help you confirm that kallisto completed successfully and show exactly what command was executed.

## Next Steps
After generating your count matrix, you can import it into analysis tools such as **Scanpy**, **Seurat**, or **Bioconductor** for downstream processing, clustering, and visualization.