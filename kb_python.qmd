---
title: "Pseudoalignment of scRNA-seq Reads with `kb-python`"
---
::: {.callout-note}
This tutorial provides a brief introduction to kb-python.
For a more in-depth guide, see the [official documentation](https://kallisto.readthedocs.io/en/latest/index.html) and reference the papers for [kb-python](https://www.nature.com/articles/s41596-024-01057-0), [bustools](http://academic.oup.com/bioinformatics/article/35/21/4472/5487510?login=true), and [kallisto](https://www.nature.com/articles/nbt.3519).
:::

**kb-python** is a lightweight, command-line toolkit for processing single-cell RNA sequencing (scRNA-seq) data. It provides an efficient and transparent way to convert raw sequencing reads into gene count matrices ready for downstream analysis.

The tool integrates two powerful components:

* **kallisto** - performs fast and accurate transcript quantification using pseudoalignment

* **bustools** - manages barcode and UMI information in the BUS (Barcode, UMI, Set) file format.

Together, these tools enable a streamlined and modular workflow that supports flexible experimental designs and efficient large-scale processing.

A typical kb-python workflow includes:

* Building a reference index with `kb ref`

* Processing **FASTQ** files into the **BUS format** with `kb count`

* Generating a count matrix summarizing gene expression per cell

:::{.callout-note title="Install seqspec"}
In order to install seqspec, follow our installation instructions [here](python_packages.qmd#kb-python).
:::

## Workflows

kb-python provides three workflows tailored to different experimental setups and analysis goals. The two most commonly used are:

* **NAC workflow** – quantifies nascent (unspliced) transcripts. This workflow is typically used for **single-nucleus RNA-seq** experiments, where a substantial portion of captured mRNA remains unspliced.

* **Standard workflow** – quantifies mature (fully spliced) transcripts. This workflow is suitable when you are interested only in processed mRNA.

## Step 1: Generate a Reference Index
The first step of any RNA-seq analysis is aligning your reads to a reference genome. To do this, kb-python requires a reference index representing the set of target transcripts to which your reads will be mapped.

### Using a Default Index
kb-python conveniently has a precompiled set of indices for the following species:

* human
* mouse
* dog 
* monkey
* zebrafish

For the **standard workflow**, you can load the human index as follows:

```bash
kb ref -d human -i index.idx -g t2g.txt
```

which will create the files index.idx and t2g.txt.

and for the **nascent workflow**,

```bash
kb ref --workflow=nac -d human -i index.idx \ 
    -g t2g.txt -c1 cdna.txt -c2 nascent.txt
```

which will additionally generate the files cdna.txt and nascent.txt.

::: {.callout-note}
See how the precompiled indices were generated [here](https://github.com/pachterlab/kallisto-transcriptome-indices)
:::

### Generating a Custom Index
In order to make a custom index, you must specify a **genome FASTA reference file** and a **GTF annotation file** from which to extract the transcript sequences. You can obtain these files from [**ENSEMBL**](https://useast.ensembl.org/index.html). We recommend using the **primary assembly FASTA file** (ends `.dna.primary_assembly.fa.gz`).

Then, to generate an index for the **standard workflow**, run:
```bash
kb ref  -i index.idx -g t2g.txt -f1 cdna.fasta genome.fasta genome.gtf
```

and for the **nac workflow**, run:
```bash
kb ref --workflow=nac -i index.idx -g t2g.txt -c1 cdna.txt -c2 nascent.txt \
    -f1 cdna.fasta -f2 nascent.fasta genome.fasta genome.gtf
```

## Step 2: Align to Reference Genome
The next step is to generate a count matrix by pseudoaligning the reads to your reference index using the `kb count` command. For example, suppose you have two paired-end FASTQ files (read1.fastq and read2.fastq) from a 10x Chromium NextGen v3 library.

For the **standard workflow**, you can perform pseudoalignment with:

```bash
kb count -i index_file.idx -g t2g_file.txt -x 10XV3 \
    -o output_dir read1.fastq read2.fastq
```

and for the **nascent workflow**,

```bash
kb count --workflow=nac -i index_file.idx -g t2g_file.txt -c1 cdna.txt \
    -c2 nascent.txt -x 10XV3 -o output_dir read1.fastq read2.fastq
```

where `output_dir` is the folder where you wish the results of `kb_count` to be stored.

::: {.callout-note title="What is a FASTQ file?"}
FASTQ files are the standard format for storing raw sequencing reads from next-generation sequencing instruments. Each read in a FASTQ file is represented by four lines:

```ruby
@SEQ_ID
GATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT
+
!''*((((***+))%%%++)(%%%%).1***-+*''))**55CCF>>>>>>CCCCCCC65
```

* **Line 1** – Read identifier (begins with @)

* **Line 2** – Nucleotide sequence

* **Line 3** – Separator line (usually just +)

* **Line 4** – Quality scores for each base (encoded as ASCII characters)

`kb count` accepts both raw and gzipped FASTQ files. If your reads are stored in another file format, you will have to convert to FASTQ before pseudoalignment with kb-python.
:::

Change `-x 10XV3` according to the specific technology you used to generate your library.

* 10X Chromium GEM-X V4: `-x 10XV4`
* Parse Evercode WT v2: `-x SPLITSEQ`

To see a complete list of technologies and their corresponding technology strings, type `kb --list` into your terminal.

### Parse Evercode WT v3: Using a Custom Specification

Currently, **kb-python** does not include a built-in specification for the **Parse Evercode WT v3** chemistry. To pseudoalign Parse v3 data, you must manually specify the assay configuration by providing:

* <a href="v3_onlist.txt" download>v3_onlist.txt</a> — a list of valid cell barcodes

* a technology string defining barcode positions within the read: `-x "1,10,18,1,30,38,1,50,58:1,0,10:0,0,0"`

* the orientation of the first read (R1) with relative to your library specification: `--strand=forward`

* the read parity (whether the assay produces single- or paired-end reads): `--paired=paired`

Then, run:
```bash
kb count --h5ad --strand=forward --parity=paired \
  -w v3_onlist.txt -x "1,10,18,1,30,38,1,50,58:1,0,10:0,0,0 \
  -g t2g.txt -i index.idx R1.fastq.gz R2.fastq.gz
```

### Parse Evercode WT: Substituting Barcodes with the `-r` Argument
The Parse Evercode WT chemistry is unique in that each cell has two cell-specific barcodes rather than one. Since kb-python expects a single barcode per cell, you must collapse barcode pairs before pseudoalignment.
This is done using the -r argument in kb count, for example:

```bash
kb count -r <replace_file> ...
```

where \<replace_file\> is a **TSV** file with two columns:

* Column 1: barcodes to be replaced

* Column 2: corresponding replacement barcodes

You can download:

* v2_replace.txt for v2 chemistry <a href="v2_replace.txt" download>here</a>

* v3_replace.txt for v3 chemistry <a href="v3_replace.txt" download>here</a>

:::{.callout-important}
When using `-r` to specify a replacement list in kb count, two count matrices will be produced: one with the original barcodes (stored in the output file `counts_unfiltered`) and one with the replacement barcodes (stored in the output file `counts_unfiltered_modified`).
:::

## Next Steps
After generating your count matrix, you can import it into analysis tools such as **Scanpy**, **Seurat**, or **Bioconductor** for downstream processing, clustering, and visualization.