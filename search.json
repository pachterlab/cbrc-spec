[
  {
    "objectID": "seqspec.html",
    "href": "seqspec.html",
    "title": "What is seqspec?",
    "section": "",
    "text": "seqspec is a simple, standardized file format to describe how a genomics library was prepared and sequenced. Different genomics assays require unique processing steps. Including a seqspec file with your data makes it easy for others (and future you!) to reanalyze your dataset. Here we will give a brief description of the seqspec format. For a more in-depth description of seqspec and the seqspec file format, refer to the GitHub page."
  },
  {
    "objectID": "seqspec.html#understanding-the-seqspec-file-format",
    "href": "seqspec.html#understanding-the-seqspec-file-format",
    "title": "What is seqspec?",
    "section": "Understanding the seqspec File Format",
    "text": "Understanding the seqspec File Format\nA seqspec file is a YAML-formatted document with three main sections:\n\nAssay Info – metadata describing the assay and protocols used\n\nLibrary Structure – layout and sequence of regions in the library\n\nRead Structure – how the sequencing reads correspond to library regions\n\nEach section depends on the specific library preparation and sequencing technology used in your assay.\n\n\n\n\n\n\nNoteWhy YAML?\n\n\n\nYAML (short for “YAML Ain’t Markup Language”) is a lightweight, human-readable format that is easy to edit and interpret, yet structured enough for automated parsing by software. This balance makes it ideal for encoding experimental metadata that must be both transparent to researchers and machine-accessible for reproducible analysis."
  },
  {
    "objectID": "seqspec.html#section-1-assay-info",
    "href": "seqspec.html#section-1-assay-info",
    "title": "What is seqspec?",
    "section": "Section 1: Assay Info",
    "text": "Section 1: Assay Info\nThe first section describes the overall experiment — what assay was used, which kit, and how it was sequenced.\n\nBasic Format\n!Assay\nseqspec_version: 0.3.0\nassay_id: \nname: \ndoi: \ndate: \ndescription:\nmodalities: rna\nlib_struct: \nsequence_protocol: \nsequence_kit: \nlibrary_protocol: \nlibrary_kit:\nseqspec_version — version of the seqspec format used (this tutorial will use version 0.3.0)\nassay_id, name, doi, date, description — metadata describing the assay\nlibrary_protocol, library_kit — kit and reagents used for library prep\nsequence_protocol, sequence_kit — sequencing instrument and reagents used\n\n\nExample\nSuppose you used the Parse Biosciences Evercode WT Mega v2.0.1 dual index kit to generate an scRNA-seq library, sequenced on Illumina NovaSeq X. The corresponding seqspec file might look like so:\n!Assay\nseqspec_version: 0.3.0\nassay_id: Evercode-WT-mega-v2-dual-index\nname: Parse Evercode Mega WT v2 using dual Illumina multiplex index\ndoi: https://www.protocols.io/view/evercode-wt-mega-v2-2-1-8epv5xxrng1b/v1?step=21\ndate: 08 November 2023\ndescription: split-pool ligation-based transcriptome sequencing\nmodalities: rna\nlib_struct: https://igvf.github.io/seqspec/\nlibrary_protocol: single-nucleus RNA sequencing assay (OBI:0003109)\nlibrary_kit: Evercode WT Mega v2.0.1 dual index\nsequence_protocol: Illumina NovaSeq X (EFO:0022840)\nsequence_kit: NovaSeq X Series 25B Reagent Kit"
  },
  {
    "objectID": "seqspec.html#section-2-library-structure",
    "href": "seqspec.html#section-2-library-structure",
    "title": "What is seqspec?",
    "section": "Section 2: Library Structure",
    "text": "Section 2: Library Structure\nThe library structure section lists all regions in the sequencing library (from 5’ to 3’), such as primers, linkers, UMIs, and barcodes.\nEach region is defined with the following template:\n- !Region\n  parent_id: \n  region_id: \n  region_type:\n  name: \n  sequence_type: \n  sequence: \n  min_len: \n  max_len: \n  onlist: \n  regions: \nregion_id, region_type, name — identifies and describes the region\nparent_id — refers to the parent region (if it exists)\nsequence, sequence_type — specifies the nucleotide sequence and its type (e.g., fixed, onlist, variable)\nmin_len, max_len — defines expected sequence lengths\nonlist — references a file or list of valid sequences (e.g., known cell barcodes)\n\nNested Regions\nParent regions can contain multiple child regions, forming a hierarchical structure. Here’s a minimal example with one parent and two child regions:\nlibrary_spec:\n- !Region\n  parent_id: null\n  region_id: parent\n  ...\n  regions:\n  - !Region\n    parent_id: parent\n    region_id: region_1\n    ...\n    regions: null\n  - !Region\n    parent_id: parent\n    region_id: region_2\n    ...\n    regions: null\n\n\nExamples\nBelow are two example regions you might find in a seqspec file.\n\nExample 1: Illumina P5 primer\n- !Region\n  parent_id: null\n  region_id: P5\n  region_type: primer\n  name: P5\n  sequence_type: fixed\n  sequence: AATGATACGGCGACCACCGAGATCTACAC\n  min_len: 29\n  max_len: 29\n  onlist: null\n  regions: null\n\n\nExample 2: Parse Biosciences Evercode WT cell barcode\n- !Region\n  parent_id: null\n  region_id: BC\n  region_type: barcode\n  name: cell barcode\n  sequence_type: onlist\n  sequence: NNNNNNNNNNNNNNNN\n  min_len: 16\n  max_len: 16\n  onlist: !Onlist\n    location: local\n    filename: onlist.txt\n  regions: null\n\n\n\n\n\n\nNoteWhat is an Onlist?\n\n\n\nIn Parse Evercode libraries, barcode regions are validated against a fixed list of known barcodes called the “onlist”."
  },
  {
    "objectID": "seqspec.html#section-3-read-structure",
    "href": "seqspec.html#section-3-read-structure",
    "title": "What is seqspec?",
    "section": "Section 3: Read Structure",
    "text": "Section 3: Read Structure\nThe read structure section links your FASTQ files to specific sequencing reads.\nEach read entry looks like this:\n- !Read\n  read_id: \n  name: \n  modality: \n  primer_id: \n  min_len: \n  max_len: \n  strand: \n  files:\nread_id, name — identifies the read object\nprimer_id — links to the corresponding primer region\nstrand — direction of sequencing relative to the library layout\nmin_len, max_len — expected read length\nfiles — references the FASTQ files containing this read\n\nExample\nsequence_spec:\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 28\n  max_len: 28\n  strand: pos\n  files:\n  - !File\n    file_id: read_1\n    filename: read_1.fastq.gz\n    filetype: fastq.gz\n    filesize: 10 GB\n    url: https://example.org/read_1.fastq.gz\n    urltype: https\n    md5: d1410f93b53357d4f95edb0ba0d73c07\n\n\nStep 3: Validate Your seqspec file with seqspec check\nYou can use seqspec check command from the seqspec package to verify your seqspec file is correctly formatted.\nInstall seqspec using pip.\npip install seqspec\nOr, if you’re using a conda environment, install it with:\nconda install -c conda-forge -c bioconda seqspec\nOnce installed, you can validate your file - let’s call it seqspec.yaml - by running:\nseqspec check seqspec.yaml\nIf your file is valid, the command will complete without errors; otherwise, it will print a description of any issues found in the specification."
  },
  {
    "objectID": "kb_python.html",
    "href": "kb_python.html",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "",
    "text": "Note\n\n\n\nThis tutorial provides a brief introduction to kb-python. For a more in-depth guide, see the official documentation.\nkb-python is a lightweight, command-line toolkit for processing single-cell RNA sequencing (scRNA-seq) data. It provides an efficient and transparent way to convert raw sequencing reads into gene count matrices ready for downstream analysis.\nThe tool integrates two powerful components:\nTogether, these tools enable a streamlined and modular workflow that supports flexible experimental designs and efficient large-scale processing.\nA typical kb-python workflow includes:"
  },
  {
    "objectID": "kb_python.html#workflows",
    "href": "kb_python.html#workflows",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "Workflows",
    "text": "Workflows\nkb-python provides three workflows tailored to different experimental setups and analysis goals. The two most commonly used are:\n\nNAC workflow – quantifies nascent (unspliced) transcripts. This workflow is typically used for single-nucleus RNA-seq experiments, where a substantial portion of captured mRNA remains unspliced.\nStandard workflow – quantifies mature (fully spliced) transcripts. This workflow is suitable when you are interested only in processed mRNA."
  },
  {
    "objectID": "kb_python.html#step-1-generate-a-reference-index",
    "href": "kb_python.html#step-1-generate-a-reference-index",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "Step 1: Generate a Reference Index",
    "text": "Step 1: Generate a Reference Index\nThe first step of any RNA-seq analysis is aligning your reads to a reference genome. To do this, kb-python requires a reference index representing the set of target transcripts to which your reads will be mapped.\nkb-python conveniently has a precompiled set of indices for the following species:\n\nhuman\nmouse\ndog\nmonkey\nzebrafish\n\n\n\n\n\n\n\nNoteWhat if kb-python doesn’t have the index I need?\n\n\n\nIf you require a custom index, please refer to Generate a reference index in the documentation.\n\n\nFor the standard workflow, you can load the human index as follows:\nkb ref -d human -i index.idx -g t2g.txt\nwhich will create the files index.idx and t2g.txt.\nand for the nascent workflow,\nkb ref --workflow=nac -d human -i index.idx \\ \n    -g t2g.txt -c1 cdna.txt -c2 nascent.txt\nwhich will additionally generate the files cdna.txt and nascent.txt.\n\n\n\n\n\n\nNote\n\n\n\nSee how the precompiled indices were generated here"
  },
  {
    "objectID": "kb_python.html#step-2-align-to-reference-genome",
    "href": "kb_python.html#step-2-align-to-reference-genome",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "Step 2: Align to Reference Genome",
    "text": "Step 2: Align to Reference Genome\nThe next step is to generate a count matrix by pseudoaligning the reads to your reference index using the kb count command. For example, suppose you have two paired-end FASTQ files (read1.fastq and read2.fastq) from a 10x Chromium NextGen v3 library.\nFor the standard workflow, you can perform pseudoalignment with:\nkb count -i index_file.idx -g t2g_file.txt -x 10XV3 \\\n    -o output_dir read1.fastq read2.fastq\nand for the nascent workflow,\nkb count --workflow=nac -i index_file.idx -g t2g_file.txt -c1 cdna.txt \\\n    -c2 nascent.txt -x 10XV3 -o output_dir read1.fastq read2.fastq\nwhere output_dir is the folder where you wish the results of kb_count to be stored.\n\n\n\n\n\n\nNoteWhat is a FASTQ file?\n\n\n\nFASTQ files are the standard format for storing raw sequencing reads from next-generation sequencing instruments. Each read in a FASTQ file is represented by four lines:\n@SEQ_ID\nGATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT\n+\n!''*((((***+))%%%++)(%%%%).1***-+*''))**55CCF&gt;&gt;&gt;&gt;&gt;&gt;CCCCCCC65\n\nLine 1 – Read identifier (begins with @)\nLine 2 – Nucleotide sequence\nLine 3 – Separator line (usually just +)\nLine 4 – Quality scores for each base (encoded as ASCII characters)\n\nkb count accepts both raw and gzipped FASTQ files. If your reads are stored in another file format, you will have to convert to FASTQ before pseudoalignment with kb-python.\n\n\nChange -x 10XV3 according to the specific technology you used to generate your library.\n\n10X Chromium GEM-X V4: -x 10XV4\nParse Evercode WT v2: -x SPLITSEQ\n\nTo see a complete list of technologies and their corresponding technology strings, type kb --list into your terminal.\n\nParse Evercode WT v3: Using a Custom Specification\nCurrently, kb-python does not include a built-in specification for the Parse Evercode WT v3 chemistry. To align Parse v3 data, you must manually specify the assay configuration by providing:\n\nv3_onlist.txt — a list of valid cell barcodes\na technology string defining barcode positions within the read: -x \"1,10,18,1,30,38,1,50,58:1,0,10:0,0,0\"\nthe orientation of the first read (R1) with relative to your library specification: --strand=forward\nthe read parity (whether the assay produces single- or paired-end reads): --paired=paired\n\nThen, run:\nkb count --h5ad --strand=forward --parity=paired \\\n  -w v3_onlist.txt -x \"1,10,18,1,30,38,1,50,58:1,0,10:0,0,0 \\\n  -g t2g.txt -i index.idx R1.fastq.gz R2.fastq.gz\n\n\nParse Evercode WT: Substituting Barcodes with the -r Argument\nThe Parse Evercode WT chemistry is unique in that each cell has two cell-specific barcodes rather than one. Since kb-python expects a single barcode per cell, you must collapse barcode pairs before pseudoalignment. This is done using the -r argument in kb count, for example:\nkb count -r &lt;replace_file&gt; ...\nwhere &lt;replace_file&gt; is a TSV file with two columns:\n\nColumn 1: barcodes to be replaced\nColumn 2: corresponding replacement barcodes\n\nYou can download:\n\nv2_replace.txt for v2 chemistry here\nv3_replace.txt for v3 chemistry here"
  },
  {
    "objectID": "kb_python.html#next-steps",
    "href": "kb_python.html#next-steps",
    "title": "Pseudoalignment of scRNA-seq Reads with kb-python",
    "section": "Next Steps",
    "text": "Next Steps\nAfter generating your count matrix, you can import it into analysis tools such as Scanpy, Seurat, or Bioconductor for downstream processing, clustering, and visualization."
  },
  {
    "objectID": "parse.html",
    "href": "parse.html",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "",
    "text": "To ensure that all data generated at Caltech are standardized and reproducible, we require that every dataset include a seqspec file. A seqspec file provides a machine-readable description of your experiment, specifying the assay information, library structure, and read structure in a YAML-formatted file."
  },
  {
    "objectID": "parse.html#step-0-get-started-with-seqspec",
    "href": "parse.html#step-0-get-started-with-seqspec",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "",
    "text": "To ensure that all data generated at Caltech are standardized and reproducible, we require that every dataset include a seqspec file. A seqspec file provides a machine-readable description of your experiment, specifying the assay information, library structure, and read structure in a YAML-formatted file."
  },
  {
    "objectID": "parse.html#step-1-align-your-library-reads-with-kb-python",
    "href": "parse.html#step-1-align-your-library-reads-with-kb-python",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "Step 1: Align Your Library Reads with kb-python",
    "text": "Step 1: Align Your Library Reads with kb-python\nAligning reads from a Parse Evercode WT library requires additional consideration compared to other scRNA-seq assays. Unlike most platforms, which use primers targeting a specific region of each mRNA molecule, Parse Evercode WT employs two types of primers — poly(T) primers that bind to the 3′ poly(A) tail and random oligo primers that bind to random internal regions of the transcript. Each primer type has its own corresponding set of cell-specific barcodes. As a result, each cell is represented by two barcodes rather than one, as in assays such as 10x Genomics.\nTo generate a unified count matrix from the raw reads, the counts associated with these two barcodes must be collapsed so that each cell is represented once. In kb-python, this is accomplished by replacing all random oligo barcodes with their corresponding poly(T) barcodes using the -r argument."
  },
  {
    "objectID": "parse.html#an-example-v2",
    "href": "parse.html#an-example-v2",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "An Example (v2)",
    "text": "An Example (v2)\nHere we provide a brief example of how to align a Parse Evercode WT v2 library to a reference using kb count. For a more in-depth tutorial, see our page on kb-python.\nTo psuedoalign your Parse data, run:\nkb count --h5ad -x SPLIT-SEQ -r v2_replace.txt \\\n  -g t2g.txt -i index.idx R1.fastq.gz R2.fastq.gz\nwhere index.idx and t2g.txt are files generated by kb-ref, and R1.fastq.gz and R2.fastq.gz are your raw paired-end reads. The replace.txt file specifies the barcode substitution. The --h5ad argument generates an h5ad formatted file for downstream processing with Scanpy.\nIf you performed a single-nucleus RNA-seq experiment, instead use the NAC workflow to align both nascent and mature reads:\nkb count --h5ad -r v2_replace.txt --workflow=nac -x 10XV3 -g t2g.txt -i index.idx \\\n  -c1 cdna.txt -c2 nascent.txt R1.fastq.gz R2.fastq.gz\nHere, cdna.txt and nascent.text are files generated by kb ref -workflow=nac.\nYou can download the file v2_replace.txt for the v2 chemistry here."
  },
  {
    "objectID": "parse.html#an-example-v3",
    "href": "parse.html#an-example-v3",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "An Example (v3)",
    "text": "An Example (v3)\nCurrently, kb-python does not include a built-in specification for Parse Evercode WT v3. Instead, we must provide the assay information manually by specifying:\n\nv3_onlist.txt — a list of valid cell barcodes\na technology string defining barcode positions within the read: -x \"1,10,18,1,30,38,1,50,58:1,0,10:0,0,0\"\nv3_replace.txt - mapping between poly(T) and random oligo barcodes\nthe orientation of the first read (R1) with relative to your library specification: --strand=forward\nthe read parity (whether the assay produces single- or paired-end reads): --paired=paired\n\nThen, run:\nkb count --h5ad --strand=forward --parity=paired \\\n  -r v3_replace.txt -w v3_onlist.txt \\\n  -x \"1,10,18,1,30,38,1,50,58:1,0,10:0,0,0 \\\n  -g t2g.txt -i index.idx R1.fastq.gz R2.fastq.gz"
  },
  {
    "objectID": "parse.html#step-2-process-and-analyze-your-data",
    "href": "parse.html#step-2-process-and-analyze-your-data",
    "title": "Analyzing Your Parse Biosciences Evercode WT scRNA-seq Assay Data",
    "section": "Step 2: Process and Analyze Your Data",
    "text": "Step 2: Process and Analyze Your Data\nNow you are ready to process your data! To continue with downstream analysis follow our example scRNA-seq pipeline."
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html",
    "href": "seqspec/webpages/Parse/parse_v3.html",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "",
    "text": "Follow one of the following links to download a template seqspec according to the Parse WT kit that you used to generate your sequencing library:\n\nParse Evercode WT Mini\nParse Evercode WT\nParse Evercode WT Mega\n\nThen, follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/Parse/parse_v3.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the Parse Evercode WT v3 Dual-Indexed Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nIllumina i5 Index\nFixed\n8 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\ncDNA\nRandom\nVariable\n\n\nRound 1 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n12 bp\n\n\nRound 2 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n12 bp\n\n\nRound 3 Barcode\nOnList\n8 bp\n\n\nUMI\nRandom\n10 bp\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n8 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\nParse Biosciences recommends that the libary be sequenced in the following way:\n\n\n\n\n\n\n\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n64\npositive\ncDNA\n\n\nIndex 1\nTruseq Read 2\n8\npositive\nIllumina i7 Index\n\n\nIndex 2\nTruseq Read 1\n8\nnegative\nIllumina i5 Index\n\n\nRead 2\nTruseq Read 2\n58\nnegative\nUMI + Barcodes + Linkers"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/Parse/parse_v3.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library. For instance, if you used the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n!Assay\nseqspec_version: 0.3.0\nassay_id: Parse-Evercode-WT-v3\nname: Dual-Indexed Parse Evercode WT v3\ndoi: https://support.parsebiosciences.com/hc/en-us/article_attachments/31841872776724\ndate: 2024-02-20\ndescription: Parse Evercode WT v3 using dual Illumina multiplex index\nmodalities: rna\nlib_struct: ##TBD##\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Parse Evercode WT v3\nlibrary_kit: Parse Evercode WT v3"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/Parse/parse_v3.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\nParse recommends that you sequence Read 1 to at least 64 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 1 by changing the ‘min_len’ and ‘max_len’ to reflect the read length. For example, if you want to sequence 150 nucleotides, upate the read as follows:\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 150\n  max_len: 150\n  strand: pos\n  files:\n  - !File\n    ...\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filepath&gt; # For Linux\n\nmd5 &lt;filepath&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filepath&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v3.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/Parse/parse_v3.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v3 Dual-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\nlibrary_spec:\n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXNNNNNNNNGAGGTGGTTGGANNNNNNNNCTGACCCCTCATNNNNNNNNNNNNNNNNNNAGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 342\n  max_len: 342\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n  ...\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html",
    "href": "seqspec/webpages/Parse/parse_v2_single.html",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "",
    "text": "Follow one of the following links to download a template seqspec according to the Parse WT kit that you used to generate your sequencing library:\n\nParse Evercode WT Mini\nParse Evercode WT\nParse Evercode WT Mega\n\nThen, follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/Parse/parse_v2_single.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the Parse Evercode WT v2 Single-Indexed Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\ncDNA\nRandom\nVariable\n\n\nRound 1 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n22 bp\n\n\nRound 2 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n30 bp\n\n\nRound 3 Barcode\nOnList\n8 bp\n\n\nUMI\nRandom\n10 bp\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n6 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\nParse Biosciences recommends that the libary be sequenced in the following way:\n\n\n\n\n\n\n\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n74\npositive\ncDNA\n\n\nIndex 1\nTruseq Read 2\n6\npositive\nIllumina i7 Index\n\n\nRead 2\nTruseq Read 2\n86\nnegative\nUMI + Barcodes + Linkers"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/Parse/parse_v2_single.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library. For instance, if you used the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n\n!Assay\nseqspec_version: 0.3.0\nassay_id: Parse-Evercode-WT-v2-single-index\nname: Single-Indexed Parse Evercode WT v2\ndoi: https://support.parsebiosciences.com/hc/en-us/article_attachments/24507636161940\ndate: 2024-02-20\ndescription: Parse Evercode WT v2 using a single Illumina multiplex index\nmodalities: rna\nlib_struct: https://igvf.github.io/seqspec/\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Parse Evercode WT v2\nlibrary_kit: Parse Evercode WT v2 Single Index"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/Parse/parse_v2_single.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\nParse recommends that you sequence Read 1 to at least 66 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 1 by changing the min_len and max_len to reflect the read length. For example, if you want to sequence 150 nucleotides, upate the read as follows:\n\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 150\n  max_len: 150\n  strand: pos\n  files:\n  - !File\n    ...\n\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \n\nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filename&gt; # For Linux\n\nmd5 &lt;filename&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filename&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_single.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/Parse/parse_v2_single.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Single-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\n\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\n\nlibrary_spec:\n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXNNNNNNNNCCACAGTCTCAAGCACGTGGATNNNNNNNNAGTCGTACGCCGATGCGAAACATCGGCCACNNNNNNNNNNNNNNNNNNAGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 368\n  max_len: 368\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n  ...\n\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html",
    "href": "seqspec/webpages/10x/10x_v3.html",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "",
    "text": "To download a template seqspec, click here, and then follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/10x/10x_v3.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the 10X Chromium Single Cell 3’ Dual-Indexed v3 Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nIllumina i5 Index\nFixed\n10 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\nCell Barcode\nRandom\n16 bp\n\n\nUMI\nRandom\n12 bp\n\n\ncDNA\nRandom\nVariable\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n10 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\n10x Genomics recommends that the libary be sequenced in the following way:\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n28\npositive\nCell Barcode + UMI\n\n\nIndex 1\nTruseq Read 2\n10\npositive\nIllumina i7 Index\n\n\nIndex 2\nTruseq Read 1\n10\nnegative\nIllumina i5 Index\n\n\nRead 2\nTruseq Read 2\n90\nnegative\ncDNA"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/10x/10x_v3.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library and the library kit that you used. For instance, if you used the Chromium Next GEM Chip G Single Cell Kit, 48 rxns PN-1000120 reagent kit to construct your library and then the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n!Assay\nseqspec_version: 0.3.0\nassay_id: 10x-RNA-v3.1-dual-index\nname: Dual Indexed 10x Genomics Chromium Single Cell 3' v3.1 \ndoi: https://cdn.10xgenomics.com/image/upload/v1722285481/support-documents/CG000315_ChromiumNextGEMSingleCell3__GeneExpression_v3.1_DualIndex__RevF.pdf\ndate: 2024-07-29\ndescription: 10x Genomics Chromium Single Cell 3' v3.1 using dual Illumina multiplex index\nmodalities: rna\nlib_struct: https://teichlab.github.io/scg_lib_structs/methods_html/10xChromium3.html\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Single-Cell RNA Sequencing Assay (OBI:0002631)\nlibrary_kit: Chromium Next GEM Chip G Single Cell Kit, 48 rxns PN-1000120"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/10x/10x_v3.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\n10x Genomics recommends that you sequence Read 2 to at least 90 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 2 by changing the min_len and max_len to reflect the read length. For example, if you want to sequence 150 nucleotides, update the read as follows:\n- !Read\n  read_id: read_2\n  name: Read 2\n  modality: rna\n  primer_id: truseq_read2\n  min_len: 150\n  max_len: 150\n  strand: neg\n  files:\n  - !File\n    ...\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filename&gt; # For Linux\n\nmd5 &lt;filename&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filename&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v3.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/10x/10x_v3.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: 10X Chromium Next GEM Single Cell 3’ v3.1 Dual-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\nlibrary_spec: \n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTNNNNNNNNNNNNNNNNNNNNNNNNNNNNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 314\n  max_len: 314\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n    ...\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to CBRC-SPEC Tutorials!",
    "section": "",
    "text": "This site is designed to guide Caltech students and staff through the full process of working with single-cell data—from formatting and processing to analysis—using the equipment and experimental setups commonly found at Caltech. Whether you’re just getting started or looking to refine your workflow, these tutorials provide step-by-step instructions tailored to our unique environment."
  },
  {
    "objectID": "index.html#explore-our-single-cell-workflows",
    "href": "index.html#explore-our-single-cell-workflows",
    "title": "Welcome to CBRC-SPEC Tutorials!",
    "section": "Explore Our Single Cell Workflows",
    "text": "Explore Our Single Cell Workflows\n\nClick a technology below to access step-by-step tutorials tailored to each single-cell assay.\n\n\nSingle-Cell RNA Sequencing Tutorials\n\n\n\n\n10x Genomics Chromium Single Cell 3’\n\n\n\n\n\n\n\nParse Biosciences Evercode WT\n\n\n\n\n\nSpatial Transcriptomics Tutorials\n\n\n\n\nseqFISH"
  },
  {
    "objectID": "sample_pipeline.html",
    "href": "sample_pipeline.html",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "",
    "text": "This notebook demonstrates pre-processing and basic analysis of the 1k Human PBMCs dataset from 10x Genomics using the 10x Genomics Chromium Single Cell 3’ Next Gen v3.1 assay."
  },
  {
    "objectID": "sample_pipeline.html#an-introductory-analysis-pipeline",
    "href": "sample_pipeline.html#an-introductory-analysis-pipeline",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "An Introductory Analysis Pipeline",
    "text": "An Introductory Analysis Pipeline\nThere are many ways to perform a single-cell RNA sequencing (scRNA-seq) analysis and many aspects of your data to explore. In this tutorial, we outline a basic approach to quality control and analysis, along with some intuitive explanation of the underlying mathematics.\n\nThis scRNA-seq workflow has the following steps:\n\nRead Alignment\nQuality Control\nCell and Gene Filters\nNormalization and Variance Stabilization\nDimensionality Reduction\nClustering and Visualization\nDifferential Expression"
  },
  {
    "objectID": "sample_pipeline.html#initial-set-up",
    "href": "sample_pipeline.html#initial-set-up",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Initial Set-Up",
    "text": "Initial Set-Up\n\nInstall Python Packages\n\n# @title\n!pip install --quiet scanpy python-igraph louvain pybiomart\n!pip install --quiet matplotlib\n!pip install --quiet scikit-learn\n!pip install --quiet numpy\n!pip install --quiet scipy\n\n!pip install --quiet kb-python==0.29.1\n\n\n# @title\n# Import packages\nimport anndata\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib_inline.backend_inline import set_matplotlib_formats\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nfrom sklearn.decomposition import TruncatedSVD\nfrom scipy import sparse, io\n\nmatplotlib.rcParams.update({'font.size': 12})\nset_matplotlib_formats('retina')\n\n/usr/local/lib/python3.12/dist-packages/scanpy/_utils/__init__.py:33: FutureWarning: `__version__` is deprecated, use `importlib.metadata.version('anndata')` instead.\n  from anndata import __version__ as anndata_version\n/usr/local/lib/python3.12/dist-packages/scanpy/__init__.py:24: FutureWarning: `__version__` is deprecated, use `importlib.metadata.version('anndata')` instead.\n  if Version(anndata.__version__) &gt;= Version(\"0.11.0rc2\"):\n/usr/local/lib/python3.12/dist-packages/scanpy/readwrite.py:16: FutureWarning: `__version__` is deprecated, use `importlib.metadata.version('anndata')` instead.\n  if Version(anndata.__version__) &gt;= Version(\"0.11.0rc2\"):\n\n\n\n\nDownload the scRNA-seq data\n\n!wget -q https://cf.10xgenomics.com/samples/cell-exp/4.0.0/SC3_v3_NextGem_SI_PBMC_CSP_1K/SC3_v3_NextGem_SI_PBMC_CSP_1K_fastqs.tar\n!tar -xf SC3_v3_NextGem_SI_PBMC_CSP_1K_fastqs.tar"
  },
  {
    "objectID": "sample_pipeline.html#step-1-read-alignment",
    "href": "sample_pipeline.html#step-1-read-alignment",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 1: Read Alignment",
    "text": "Step 1: Read Alignment\n\nDownload a Pre-Built Index with kb ref\n\n!kb ref -d human -i index.idx -g t2g.txt\n\n[2025-10-21 04:48:16,146]    INFO [download] Skipping download because some files already exist. Use the --overwrite flag to overwrite.\n\n\n\n\nPseudoalign the scRNA-seq Data to the Index with kb count\n\n# This step runs `kb` to pseudoalign the reads, and then generate the cells x gene matrix in h5ad format.\n!kb count -i index.idx -g t2g.txt -x 10XV3 --h5ad -t 2 \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L002_R1_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L002_R2_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L003_R1_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L003_R2_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L004_R1_001.fastq.gz \\\nSC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_fastqs/SC3_v3_NextGem_SI_CSP-Labeled_PBMCs_1K_gex_S1_L004_R2_001.fastq.gz\n\n[2025-10-21 04:48:27,652]    INFO [count] Skipping kallisto bus because output files already exist. Use the --overwrite flag to overwrite.\n[2025-10-21 04:48:27,652]    INFO [count] Sorting BUS file ./output.bus to ./tmp/output.s.bus\n[2025-10-21 04:48:46,541]    INFO [count] On-list not provided\n[2025-10-21 04:48:46,541]    INFO [count] Copying pre-packaged 10XV3 on-list to .\n[2025-10-21 04:48:47,999]    INFO [count] Inspecting BUS file ./tmp/output.s.bus\n[2025-10-21 04:49:06,258]    INFO [count] Correcting BUS records in ./tmp/output.s.bus to ./tmp/output.s.c.bus with on-list ./10x_version3_whitelist.txt\n[2025-10-21 04:49:31,255]    INFO [count] Sorting BUS file ./tmp/output.s.c.bus to ./output.unfiltered.bus\n[2025-10-21 04:49:38,691]    INFO [count] Generating count matrix ./counts_unfiltered/cells_x_genes from BUS file ./output.unfiltered.bus\n[2025-10-21 04:49:47,233]    INFO [count] Writing gene names to file ./counts_unfiltered/cells_x_genes.genes.names.txt\n[2025-10-21 04:49:47,817] WARNING [count] 13914 gene IDs do not have corresponding valid gene names. These genes will use their gene IDs instead.\n[2025-10-21 04:49:47,866]    INFO [count] Reading matrix ./counts_unfiltered/cells_x_genes.mtx\n[2025-10-21 04:49:48,887]    INFO [count] Writing matrix to h5ad ./counts_unfiltered/adata.h5ad\n\n\nWhen the --h5ad argument is used, kb count generates a H5AD-formatted Anndata matrix for downstream processing.\n\n\nLoad the Anndata Object\nFor this tutorial we will be using the Python package Scanpy.\nScanpy is a scalable Python library for analyzing single-cell RNA sequencing (scRNA-seq) data, built around an efficient AnnData object that stores expression matrices and associated metadata. It provides a comprehensive toolkit for preprocessing, visualization, clustering, and differential expression, enabling end-to-end analysis of large single-cell datasets.\nBelow we load the cells x genes matrix generated by kb-python as a H5AD-formatted object so that we can analyze our data with Scanpy.\n\n# import data\nadata = anndata.read_h5ad('counts_unfiltered/adata.h5ad')\nadata\n\nAnnData object with n_obs × n_vars = 281262 × 39546\n\n\n\n# Load the gene names and make them a column in the var dataframe\nwith open(\"counts_unfiltered/cells_x_genes.genes.names.txt\", 'r') as file:\n  adata.var['gene_names'] = file.readlines()"
  },
  {
    "objectID": "sample_pipeline.html#step-2-basic-quality-control",
    "href": "sample_pipeline.html#step-2-basic-quality-control",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 2: Basic Quality Control",
    "text": "Step 2: Basic Quality Control\n\nTest for Library Saturation\nBelow is a Gene vs. UMI plot, in which, for each cell, we visualize how many genes we detected. The purpose of this plot is to see if we have “saturated” our sequencing library and sampled a representative number of mRNA molecules for each cell. If this is the case, then increasing the number of UMI counts (x-axis) will not yield an appreciable increase in the number of genes detected (y-axis).\n\n# Create a plot showing genes detected as a function of UMI counts.\nfig, ax = plt.subplots(figsize=(10, 7))\n\nx = np.asarray(adata.X.sum(axis=1))[:,0]\ny = np.asarray(np.sum(adata.X&gt;0, axis=1))[:,0]\n\nax.scatter(x, y, color=\"green\", alpha=0.25)\nax.set_xlabel(\"UMI Counts\")\nax.set_ylabel(\"Genes Detected\")\nax.set_xscale('log')\nax.set_yscale('log', nonpositive='clip')\n\nax.set_xlim((0.5, 4500))\nax.set_ylim((0.5,2000))\n\n\nplt.show()\n\n\n\n\n\n\n\n\nThe data looks good! The number of genes does not increase appreciably relative to the number of UMI counts as demonstrated by the linear relationship between genes to UMI counts in the above log-log plot.\n\n\nExamine the Knee Plot\nIn microfluidics-based scRNA-seq assays, such as the 10x Genomics Chromium platform, cells are encapsulated into droplets at low concentrations to minimize the formation of multiplets (droplets containing more than one cell). However, this approach also results in many droplets that contain no cells at all.\nDuring cell dissociation and droplet generation, some mRNA molecules are released into the surrounding solution — known as ambient RNA. When this ambient RNA is captured and sequenced, empty droplets may falsely appear to contain a cell.\nThe knee plot helps distinguish real cells from empty droplets based on total UMI counts per droplet. It was first introduced in the Drop-seq paper by Macosko et al., 2015.\nIn this plot, barcodes (droplets) are ranked by the number of associated UMI counts (shown on the x-axis), while the fraction of droplets with at least that many UMIs is shown on the y-axis. The “knee” of the curve represents the point where UMI counts drop sharply — separating droplets that likely contain real cells from those containing only ambient RNA.\n\n#@title Threshold Cells According to Knee Plot { run: \"auto\", vertical-output: true }\ncutoff = 400  #@param {type:\"integer\"}\nknee = np.sort((np.array(adata.X.sum(axis=1))).flatten())[::-1]\ncell_set = np.arange(len(knee))\nnum_cells = cell_set[knee &gt; cutoff][::-1][0]\n\nfig, ax = plt.subplots(figsize=(10, 7))\n\n\nax.loglog(knee, cell_set, linewidth=5, color=\"g\")\nax.axvline(x=cutoff, linewidth=3, color=\"k\")\n\n\nax.axhline(y=num_cells, linewidth=3, color=\"k\")\n\nax.set_xlabel(\"UMI Counts\")\nax.set_ylabel(\"Set of Barcodes\")\n\nplt.grid(True, which=\"both\")\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(f\"{num_cells:,.0f} cells passed the {cutoff} UMI threshold\")\n\n1,212 cells passed the 400 UMI threshold\n\n\nThe knee plot can be used to threshold cells based on the number of UMI counts they contain. In this example we use the number 3979 based on the publication describing the data."
  },
  {
    "objectID": "sample_pipeline.html#step-3-doublet-and-multiplet-removal",
    "href": "sample_pipeline.html#step-3-doublet-and-multiplet-removal",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 3: Doublet and Multiplet Removal",
    "text": "Step 3: Doublet and Multiplet Removal\n\nFilter empty droplets (According to the Knee Plot)\nIdeally, your data will contain no empty droplets that can be mistaken for real cells. We use our results from the knee plot here to filter them out.\n\n# Filter the cells according to the threshold determined from the knee plot\nsc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_cells(adata, min_counts=knee[num_cells])\n\n\n\n\n\n\n\nNote\n\n\n\nThe knee plot is a very simple method for getting rid of empty droplets. More sophisticated methods also exist. For instance, the methods EmptyDrops, CellBender, and DecontX use a statistical model to distinguish counts from ambient vs. cellular mRNA. This allows for both the identification and removal of empty droplets and the removal of technical noise from your count data.\n\n\n\n\nFilter Multiplets with Scrublet\nScrublet is an package designed to identify and remove multiplets (droplets containing more than one cell) from scRNA-seq data. It works by simulating artificial doublets through random pairwise combinations of real cells’ expression profiles. Scrublet then embeds both the simulated and observed cells in a low-dimensional space and flags real cells that lie close to simulated doublets as potential multiplets.\nScrublet operates on a raw count matrix, but requires that empty droplets be removed beforehand. If empty droplets remain in the dataset, they can distort the simulated doublet distribution and lead to inaccurate classifications. In addition, the Scrublet package should be applied to each sample/batch individually to avoid batch effects distorting the simulated doublet distribution.\nRemoving multiplets is an important quality-control step, as doublets can appear as hybrid cell types and obscure true biological variation during clustering and downstream analyses.\n\n\n\n\n\n\nNote\n\n\n\nThe Scrublet package is convenient because it is built-in to Scanpy, but it is not the only nor the most accurate doublet removal method. For a review of doublet detection methods, refer to the paper Benchmarking computational doublet-detection methods for single-cell RNA sequencing data by Nan Miles Chi and Jingyi Jessica Li.\n\n\n\nsc.pp.scrublet(adata, expected_doublet_rate=0.008)\n\n/usr/local/lib/python3.12/dist-packages/scanpy/neighbors/__init__.py:430: FutureWarning: Use obsm (e.g. `k in adata.obsm` or `adata.obsm.keys() | {'u'}`) instead of AnnData.obsm_keys, AnnData.obsm_keys is deprecated and will be removed in the future.\n  if \"X_diffmap\" in adata.obsm_keys():\n\n\nThe expected doublet rate depends upon your assay and the number of cells targeted. Refer to the documentation for you specific technology to get this number. We got the expected double rate 0.008 for 1,000 cells for 10x Chromium NextGem v3.1 here.\n\nadata = adata[adata.obs['predicted_doublet'] == False]\n\n\n\nFiltering Cells by Mitochondrial Content\nA healthy, intact cell should have no miRNA in the cytoplasm. As such, a high percentage of miRNA in the cytosol indicates cellular damage. We will identify the number of miRNA in each cell and remove cells with a certain percentage of miRNA.\n\nmito_ensembl_ids = sc.queries.mitochondrial_genes(\"hsapiens\", attrname=\"ensembl_gene_id\")\nmito_genes = set(mito_ensembl_ids[\"ensembl_gene_id\"].values)\n\nadata_base_var_names = adata.var_names.str.split('.').str[0]  # Removes minor version from var names\nmito_genes_base = {gene.split('.')[0] for gene in mito_genes}  # Removes minor version from mito_genes\n\n# Identify mitochondrial genes in adata.var using the stripped version of gene IDs\nadata.var['is_mito'] = adata_base_var_names.isin(mito_genes_base)\n\nmito_counts = adata[:, adata.var['is_mito']].X.sum(axis=1)\n\n# Calculate total counts per cell\ntotal_counts = adata.X.sum(axis=1)\n\n# Calculate percent mitochondrial gene expression per cell\nadata.obs['percent_mito'] = np.array(mito_counts / total_counts * 100).flatten()\n\nadata.obs['n_counts'] = adata.X.sum(axis=1).A1\n\n/tmp/ipython-input-2771333037.py:8: ImplicitModificationWarning: Trying to modify attribute `.var` of view, initializing view as actual.\n  adata.var['is_mito'] = adata_base_var_names.isin(mito_genes_base)\n\n\n\nsc.pl.scatter(adata, x='n_counts', y='percent_mito')\n\n/usr/local/lib/python3.12/dist-packages/scanpy/plotting/_anndata.py:397: FutureWarning: Use obs (e.g. `k in adata.obs` or `str(adata.obs.columns.tolist())`) instead of AnnData.obs_keys, AnnData.obs_keys is deprecated and will be removed in the future.\n  if key in adata.obs_keys():\n\n\n\n\n\n\n\n\n\nWe see above that the highest density of cells appear to have less than 30% miRNA content, so we will set our threshold to 30%\n\nadata = adata[adata.obs.percent_mito &lt; 30]\n\n\n\nFilter out genes that are not present in any cells\nIn general, we also want to get rid of genes with a low cell count to simplify our data.\n\nsc.pp.filter_genes(adata, min_cells=3)\n\n/usr/local/lib/python3.12/dist-packages/scanpy/preprocessing/_simple.py:293: ImplicitModificationWarning: Trying to modify attribute `.var` of view, initializing view as actual.\n  adata.var[\"n_cells\"] = number\n\n\n\n\nVisualizing count distributions\nExamination of the gene count and UMI count distributions is useful QC to evaluate the quality of the library and how deeply it was sequenced.\n\nsc.pl.violin(adata, ['n_genes', 'n_counts', 'percent_mito'], jitter=0.4, multi_panel=True)"
  },
  {
    "objectID": "sample_pipeline.html#step-4-normalization-and-variance-stabilization",
    "href": "sample_pipeline.html#step-4-normalization-and-variance-stabilization",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 4: Normalization and Variance Stabilization",
    "text": "Step 4: Normalization and Variance Stabilization\nIn an scRNA-seq experiment, UMI counts provide a relative estimate of transcript abundance within each cell. During library preparation and sequencing, mRNA molecules from different cells are reverse transcribed and sequenced to varying degrees. As a result, UMI counts cannot be interpreted as absolute measurements of RNA abundance.\nTo make counts comparable across cells, we normalize the data so that each cell has a total of 1×10⁶ counts. This scaling preserves integer values while allowing gene expression levels to be expressed as relative abundances within each cell.\nDownstream analyses such as PCA and differential expression typically assume that gene expression values are approximately continuous and have roughly constant variance across their range. However, raw scRNA-seq counts are overdispersed — they follow a negative binomial–like distribution, where the variance increases with the mean. To stabilize the variance and make the data more compatible with these methods, we apply a log transformation to the normalized counts.\n\n\n\n\n\n\nNote\n\n\n\nThis is a simplified approach for addressing overdispersion. Although log normalization is widely used, it does entirely produce constant-variance data. More sophisticated methods (e.g., variance-stabilizing transformations or model-based approaches) can better correct for overdispersion, but no perfect method currently exists — and those techniques are beyond the scope of this tutorial.\n\n\n\nsc.pp.normalize_total(adata, target_sum=1e6)\n\n\nsc.pp.log1p(adata)\n\n\nIdentify Highly Variable Genes\nTo simplify our data and reduce its dimensionality for downstream analyses, we limit our dataset to highly variable genes. Genes with low expression variance — such as housekeeping genes — contribute little to distinguishing between cell types or states, and can be excluded without loss of biological signal.\nHere, we retain only genes with a mean expression between 0.01 and 8 (values above 8 likely indicate technical artifacts) and a minimum normalized dispersion of 1. Cells are grouped (binned) by mean gene expression, and genes within each bin are filtered based on their normalized dispersion values.\n\n\n\n\n\n\nNote\n\n\n\nThe sc.pp.highly_variable_genes function in Scanpy expects input data that have already been normalized and variance-stabilized.\n\n\n\nsc.pp.highly_variable_genes(adata, min_mean=0.01, max_mean=8, min_disp=1, n_bins=20, flavor=\"seurat\")\nsc.pl.highly_variable_genes(adata)\n\n\n\n\n\n\n\n\nFinally, we scale the the data to unit variance and zero mean to standardize gene expression by preventing highly expressed genes from dominating downstream analysis and ensuring all genes are weighted equally.\n\nsc.pp.scale(adata, max_value=10)\n\n/usr/lib/python3.12/functools.py:912: UserWarning: zero-centering a sparse array/matrix densifies it.\n  return dispatch(args[0].__class__)(*args, **kw)"
  },
  {
    "objectID": "sample_pipeline.html#step-5-clustering-and-visualization",
    "href": "sample_pipeline.html#step-5-clustering-and-visualization",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 5: Clustering and Visualization",
    "text": "Step 5: Clustering and Visualization\nWhen analyzing scRNA-seq data, clustering is used to identify distinct cell types and states. Subsequently, differential expression analysis can reveal the genes that define these cellular states.\nThere are many algorithms for clustering cells, and while they have been compared in detail in various benchmarks (see e.g., Duo et al. 2018), there is no univerally agreed upon method. Here we demonstrate clustering using Louvain clustering, which is a popular method for clustering single-cell RNA-seq data.\n\n\n\n\n\n\nNote\n\n\n\nLouvain clustering is a non-deterministic algorithm, meaning it can produce slightly different results across runs. The number and size of clusters depend on a resolution parameter, which controls the granularity of the clustering. There is no universally optimal way to choose this parameter — it typically depends on how specific or fine-grained you want your cell populations to be.\n\n\n\nsc.pp.pca(adata, mask_var=\"highly_variable\")\n\n/usr/local/lib/python3.12/dist-packages/scanpy/preprocessing/_pca/__init__.py:245: FutureWarning: `__version__` is deprecated, use `importlib.metadata.version('anndata')` instead.\n  Version(ad.__version__) &lt; Version(\"0.9\")\n\n\n\n# Cluster the cells using Louvain clustering\nsc.pp.neighbors(adata, n_neighbors=30, n_pcs=10, knn=True)\nsc.tl.louvain(adata, resolution = 1.0)\n\n/usr/local/lib/python3.12/dist-packages/scanpy/neighbors/__init__.py:430: FutureWarning: Use obsm (e.g. `k in adata.obsm` or `adata.obsm.keys() | {'u'}`) instead of AnnData.obsm_keys, AnnData.obsm_keys is deprecated and will be removed in the future.\n  if \"X_diffmap\" in adata.obsm_keys():\n\n\nIt is useful to revisit the PCA projection with points colored by cluster. Previously we computed the PCA projection directly; here we use a function in Scanpy which does the same.\n\nVisualization with PCA\n\n# Perform PCA and plot the projection to the first two dimensions, with points colored according to the Louvain clusters.\nfig, ax = plt.subplots(figsize=(10, 7))\nsc.pl.pca(adata, color='louvain', ax=ax)\n\n\n\n\n\n\n\n\n\n\nNonlinear Visualization\nThe PCA representation results from a linear projection of the data from its original high-dimensional space to a lower-dimensional one (in this case, 2D). Such projections are valuable because they preserve global structure and are mathematically well-defined and reproducible.\nIn contrast, non-linear dimensionality reduction methods—the most popular being t-SNE and UMAP—can reveal complex, curved relationships in the data that linear methods cannot capture. However, they distort global distances and relationships, depend heavily on algorithmic parameters and random initialization, and may produce different results across runs. As a result, they are excellent for visualization but should be interpreted cautiously and not used for quantitative downstream analysis.\nTo read more, please see the Pachter Lab’s paper on the drawbacks of non-linear dimensionality reduction methods.\n\nt-SNE\n\n# Visualize cells with t-SNE. The n_pcs parameter sets the number of principal components to project to prior to\n# performing t-SNE\nsc.tl.tsne(adata, n_pcs=10)\nfig, ax = plt.subplots(figsize=(10, 7))\nsc.pl.tsne(adata, color='louvain', ax=ax)\n\n\n\n\n\n\n\n\n\n\nUMAP\n\n%%time\nsc.tl.umap(adata)\nfig, ax = plt.subplots(figsize=(10, 7))\nsc.pl.umap(adata, color='louvain', ax=ax)\n\n\n\n\n\n\n\n\nCPU times: user 3.07 s, sys: 7.18 ms, total: 3.08 s\nWall time: 2.97 s"
  },
  {
    "objectID": "sample_pipeline.html#step-6-differential-analysis",
    "href": "sample_pipeline.html#step-6-differential-analysis",
    "title": "\nIntroductory scRNA-seq Analysis with kb-python and Scanpy\n",
    "section": "Step 6: Differential Analysis",
    "text": "Step 6: Differential Analysis\nFrom our clustering of cell states, we can perform differential expression analysis to identify marker genes that distinguish one cell state or cluster from another. This is typically done using simple statistical tests — such as the Wilcoxon rank-sum test or the t-test — which compare gene expression levels between clusters, or alternatively by fitting a more complex statistical model that accounts for variability across cells. By examining which genes are upregulated in each cluster, we can annotate clusters with known cell identities or infer novel cellular subpopulations.\nBelow, we use the Wilcoxon rank-sum test to identify marker genes. Because we are performing multiple hypothesis tests on the same dataset, we must adjust our p-values to control the false discovery rate. Several correction methods exist, but here we apply the Benjamini–Hochberg procedure, a widely used approach for multiple testing correction.\n\n\n\n\n\n\nNote\n\n\n\nStatistical tests such as the Wilcoxon rank-sum test and the t-test assume that the groups being compared were defined independently of the data. However, in single-cell analysis, clustering algorithms like Louvain define groups based on the data itself — by minimizing within-cluster variation and maximizing between-cluster separation. This violates the independence assumption, meaning these tests are not strictly valid. Despite this, they remain common in practice and can still provide useful exploratory insights when interpreted cautiously.\n\n\n\nsc.tl.rank_genes_groups(adata, gene_symbols='gene_names', groupby='louvain', method='wilcoxon')\n\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n/usr/local/lib/python3.12/dist-packages/scanpy/tools/_rank_genes_groups.py:482: RuntimeWarning: invalid value encountered in log2\n  self.stats[group_name, \"logfoldchanges\"] = np.log2(\n\n\nThe below plot shows the 10 most highly expressed genes in each cluster (compared to the other clusters) according to the Wilcoxon z-score.\n\nsc.pl.rank_genes_groups(adata, n_genes=10, gene_symbols='gene_names', groupby='louvain', method='wilcoxon')"
  },
  {
    "objectID": "seqfish.html",
    "href": "seqfish.html",
    "title": "seqFISH",
    "section": "",
    "text": "seqFISH is a powerful imaging-based single-cell transcriptomics technique that enables the spatial mapping of gene expression directly within tissue samples. Unlike droplet-based methods such as 10x Chromium or Parse Evercode, seqFISH preserves spatial context—allowing you to see not only which genes are active, but where they’re expressed within the cellular architecture.\n\n\n\nFigure: seqFish Mouse Embryo Map"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html",
    "href": "seqspec/webpages/10x/10x_v4.html",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "",
    "text": "To download a template seqspec, click here, and then follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/10x/10x_v4.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the 10X Chromium Single Cell 3’ Dual-Indexed v4 Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nIllumina i5 Index\nFixed\n10 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\nCell Barcode\nRandom\n16 bp\n\n\nUMI\nRandom\n12 bp\n\n\ncDNA\nRandom\nVariable\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n10 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\n10x Genomics recommends that the libary be sequenced in the following way:\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n28\npositive\nCell Barcode + UMI\n\n\nIndex 1\nTruseq Read 2\n10\npositive\nIllumina i7 Index\n\n\nIndex 2\nTruseq Read 1\n10\nnegative\nIllumina i5 Index\n\n\nRead 2\nTruseq Read 2\n90\nnegative\ncDNA"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/10x/10x_v4.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library. For instance, if you used the Chromium GEM-X Single Cell 3’ Kit v4, 16 rxns PN-1000691 reagent kit to construct your library and then the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n!Assay\nseqspec_version: 0.3.0\nassay_id: 10x-RNA-v4\nname: Dual Indexed 10x Genomics Chromium Single Cell 3' v4\ndoi: https://cdn.10xgenomics.com/image/upload/v1725314293/support-documents/CG000732_ChromiumGEM-X_SingleCell3_v4_CellSurfaceProtein_UserGuide_RevB.pdf\ndate: 2025-04-18\ndescription: 10x Genomics Chromium Single Cell 3' v4 using dual Illumina multiplex index\nmodalities: rna\nlib_struct: https://teichlab.github.io/scg_lib_structs/methods_html/10xChromium3.html\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Single-Cell RNA Sequencing Assay (OBI:0002631)\nlibrary_kit: Chromium GEM-X Single Cell 3' Kit v4, 16 rxns PN-1000691"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/10x/10x_v4.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\n10x Genomics recommends that you sequence Read 2 to at least 90 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 2 by changing the min_len and max_len to reflect the read length. For example, if you want to sequence 150 nucleotides, update the read as follows:\n- !Read\n  read_id: read_2\n  name: Read 2\n  modality: rna\n  primer_id: truseq_read2\n  min_len: 150\n  max_len: 150\n  strand: neg\n  files:\n  - !File\n    ...\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filename&gt; # For Linux\n\nmd5 &lt;filename&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filename&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/10x/10x_v4.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/10x/10x_v4.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: 10X Chromium GEM-X Single Cell 3’ v4 Dual-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\nlibrary_spec: \n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTNNNNNNNNNNNNNNNNNNNNNNNNNNNNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 314\n  max_len: 314\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n    ...\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "",
    "text": "Follow one of the following links to download a template seqspec according to the Parse WT kit that you used to generate your sequencing library:\n\nParse Evercode WT Mini\nParse Evercode WT\nParse Evercode WT Mega\n\nThen, follow this tutorial to tailor the seqspec to your dataset."
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html#summmary-of-library-structure-and-sequencing",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html#summmary-of-library-structure-and-sequencing",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "Summmary of Library Structure and Sequencing",
    "text": "Summmary of Library Structure and Sequencing\n\n\n\n\n\nAbove is a diagram of the Parse Evercode WT v2 Dual-Indexed Library. The library is structured as follows from 5’ to 3’:\n\n\n\nSequence\nType\nLength\n\n\n\n\nIllumina P5 Primer\nFixed\n29 bp\n\n\nIllumina i5 Index\nFixed\n8 bp\n\n\nTruseq Read 1\nFixed\n29 bp\n\n\ncDNA\nRandom\nVariable\n\n\nRound 1 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n22 bp\n\n\nRound 2 Barcode\nOnList\n8 bp\n\n\nLinker\nFixed\n30 bp\n\n\nRound 3 Barcode\nOnList\n8 bp\n\n\nUMI\nRandom\n10 bp\n\n\nTruseq Read 2\nFixed\n34 bp\n\n\nIllumina i7 Index\nFixed\n10 bp\n\n\nIllumina P7 Primer\nFixed\n24 bp\n\n\n\n\nParse Biosciences recommends that the libary be sequenced in the following way:\n\n\n\n\n\n\n\n\n\n\nName\nPrimer\nCycles\nStrand\nCoverage\n\n\n\n\nRead 1\nTruseq Read 1\n66\npositive\ncDNA\n\n\nIndex 1\nTruseq Read 2\n8\npositive\nIllumina i7 Index\n\n\nIndex 2\nTruseq Read 1\n8\nnegative\nIllumina i5 Index\n\n\nRead 2\nTruseq Read 2\n86\nnegative\nUMI + Barcodes + Linkers"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html#step-1-fill-in-the-assay-info",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html#step-1-fill-in-the-assay-info",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "Step 1: Fill in the Assay Info",
    "text": "Step 1: Fill in the Assay Info\nFill in the missing assay info according to the technology you used to sequence your library. For instance, if you used the Illumina NextSeq 2000 sequencer with the P3 reagent kit, your assay info section would look like:\n!Assay\nseqspec_version: 0.3.0\nassay_id: Parse-Evercode-WT-v2-dual-index\nname: Dual-Indexed Parse Evercode WT v2\ndoi: https://support.parsebiosciences.com/hc/en-us/article_attachments/24507636161940\ndate: 2024-02-20\ndescription: Parse Evercode WT v2 using dual Illumina multiplex index\nmodalities: rna\nlib_struct: https://igvf.github.io/seqspec/\nsequence_protocol: Illumina NextSeq 2000\nsequence_kit: Illumina NextSeq 2000 P3 XLEAP-SBS Reagent kit\nlibrary_protocol: Parse Evercode WT v2\nlibrary_kit: Parse Evercode WT v2 Dual Index"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html#step-2-alter-the-sequence-spec",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html#step-2-alter-the-sequence-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "Step 2: Alter the Sequence Spec",
    "text": "Step 2: Alter the Sequence Spec\n\nUpdate the Read Objects\nParse recommends that you sequence Read 1 to at least 66 nucleotides, but you may have decided to sequence to up to 150 nucleotides. If that is the case, you can modify the length of Read 1 by changing the min_len and max_len to reflect the read length. For example, if you want to sequence 150 nucleotides, upate the read as follows:\n- !Read\n  read_id: read_1\n  name: Read 1\n  modality: rna\n  primer_id: truseq_read1\n  min_len: 150\n  max_len: 150\n  strand: pos\n  files:\n  - !File\n    ...\nYou may have also decided not to sequence the sample indices if you did not sequence multiple samples at once. In this case, you should remove the Index 1 and Index 2 read objects.\n\n\nAdd in the file objects\nNext, for each read, you should fill out a file object referencing the corresponding file.\nA file object in seqspec if formatted as follows:\n- !File\n      file_id: \n      filename:\n      filetype: \n      filesize: \n      url: \n      urltype: \n      md5: \nfile_id, filetype, filename — identifies and describes the file\nfilesize - the size of the file\nurl - (optional) the link to the file\nurltype - (optional) the type of url\nmd5 - (optional) MD5 fingerprint of data\n\n\n\n\n\n\nNoteWhat does md5 stand for?\n\n\n\nAn MD5 checksum is a short, unique string of letters and numbers generated from a file’s contents. It acts like a digital fingerprint — if even a single byte in the file changes, the checksum will be different.\nIncluding the MD5 value for your files allows others to verify data integrity after download or transfer, ensuring that the file has not been corrupted or altered.\nTo generate an MD5 checksum string, type into your command-line:\nmd5sum &lt;filename&gt; # For Linux\n\nmd5 &lt;filename&gt; # For macOS\n\nGet-FileHash -Algorithm MD5 -Path &lt;filename&gt; # For Windows"
  },
  {
    "objectID": "seqspec/webpages/Parse/parse_v2_dual.html#step-3-alter-the-library-spec",
    "href": "seqspec/webpages/Parse/parse_v2_dual.html#step-3-alter-the-library-spec",
    "title": "seqspec Tutorial: Parse Evercode WT v2 Dual-Indexed Library",
    "section": "Step 3: Alter the Library Spec",
    "text": "Step 3: Alter the Library Spec\nYou can modify the min_len and max_len values for the cDNA region to reflect your desired read length. For example, if you want to sequence 150 nucleotides of cDNA, update the region as follows:\n    - !Region\n        parent_id: rna\n        region_id: cdna\n        region_type: cdna\n        name: cDNA\n        sequence_type: random\n        sequence: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        min_len: 150\n        max_len: 150\n        onlist: null\n        regions: null\nAdjust the number of X characters in the sequence field to match the new length, and then adjust the full library sequence and length accordingly.\nlibrary_spec:\n- !Region\n  region_id: rna\n  region_type: named\n  name: rna\n  sequence_type: joined\n  sequence: AATGATACGGCGACCACCGAGATCTACACNNNNNNNNTCTTTCCCTACACGACGCTCTTCCGATCTXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXNNNNNNNNCCACAGTCTCAAGCACGTGGATNNNNNNNNAGTCGTACGCCGATGCGAAACATCGGCCACNNNNNNNNNNNNNNNNNNAGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG\n  min_len: 368\n  max_len: 368\n  onlist: null\n  parent_id: null\n  regions:\n  - !Region\n  ...\n\nNow you have a complete seqspec file for your data. All that’s left is to save it with your dataset!"
  },
  {
    "objectID": "contact_us.html",
    "href": "contact_us.html",
    "title": "Contact Us",
    "section": "",
    "text": "Name \nEmail \nMessage\n\n\nSend Message"
  },
  {
    "objectID": "contact_us.html#still-have-questions-were-here-to-help",
    "href": "contact_us.html#still-have-questions-were-here-to-help",
    "title": "Contact Us",
    "section": "",
    "text": "Name \nEmail \nMessage\n\n\nSend Message"
  },
  {
    "objectID": "seqspec_tutorials.html",
    "href": "seqspec_tutorials.html",
    "title": "Choose an Assay to Begin Your seqspec Tutorial",
    "section": "",
    "text": "10x Genomics Next GEM v3\n    \n    \n      \n      10x Genomics GEM X v4\n    \n  \n\n  \n  \n    \n      \n      Parse Evercode WT v2 (Single Index)\n    \n    \n      \n      Parse Evercode WT v2 (Dual Index)\n    \n    \n      \n      Parse Evercode WT v3"
  },
  {
    "objectID": "10x.html",
    "href": "10x.html",
    "title": "Analyzing Your 10x Chromium Single Cell 3’ scRNA-seq Assay Data",
    "section": "",
    "text": "To ensure that all data generated at Caltech are standardized and reproducible, we require that every dataset include a seqspec file. A seqspec file provides a machine-readable description of your experiment, specifying the assay information, library structure, and read structure in a YAML-formatted file."
  },
  {
    "objectID": "10x.html#step-0-get-started-with-seqspec",
    "href": "10x.html#step-0-get-started-with-seqspec",
    "title": "Analyzing Your 10x Chromium Single Cell 3’ scRNA-seq Assay Data",
    "section": "",
    "text": "To ensure that all data generated at Caltech are standardized and reproducible, we require that every dataset include a seqspec file. A seqspec file provides a machine-readable description of your experiment, specifying the assay information, library structure, and read structure in a YAML-formatted file."
  },
  {
    "objectID": "10x.html#step-1-align-your-library-reads-with-kb-python",
    "href": "10x.html#step-1-align-your-library-reads-with-kb-python",
    "title": "Analyzing Your 10x Chromium Single Cell 3’ scRNA-seq Assay Data",
    "section": "Step 1: Align Your Library Reads with kb-python",
    "text": "Step 1: Align Your Library Reads with kb-python\nAligning reads from a 10x Genomics Library is relatively straightforward. After generating a reference index with kb ref, align your reads to the reference with kb count.\n\nAn Example\nHere we provide a brief example of how to align a 10x library to a reference using kb count. For a more in-depth tutorial, see our page on kb-python.\nTo psuedoalign your scRNA-seq 10x data, run:\nkb count --h5ad -x 10XV3 -g t2g.txt -i index.idx \\\n  R1.fastq.gz R2.fastq.gz\nwhere index.idx and t2g.txt are files generated by kb ref, and R1.fastq.gz and R2.fastq.gz are your raw paired-end reads. The --h5ad argument outputs an .h5ad file suitable for downstream processing with Scanpy.\nIf you performed a single-nucleus RNA-seq experiment, instead use the NAC workflow to align both nascent and mature reads:\nkb count --h5ad -x 10XV3 --workflow=nac -g t2g.txt -i index.idx  \\ \n  -c1 cdna.txt -c2 nascent.txt R1.fastq.gz R2.fastq.gz\nHere, cdna.txt and nascent.text are files generated by kb ref --workflow=nac.\n\n\n\n\n\n\nImportant\n\n\n\nThis example is specifically for the 10x Chromium Single Cell Next Gem v3 chemistry for the v4 chemistry, replace the technology string -x 10XV3 with -x 10XV4."
  },
  {
    "objectID": "10x.html#step-2-process-and-analyze-your-data",
    "href": "10x.html#step-2-process-and-analyze-your-data",
    "title": "Analyzing Your 10x Chromium Single Cell 3’ scRNA-seq Assay Data",
    "section": "Step 2: Process and Analyze Your Data",
    "text": "Step 2: Process and Analyze Your Data\nNow you are ready to process your data! To continue with downstream analysis follow our example scRNA-seq pipeline."
  }
]